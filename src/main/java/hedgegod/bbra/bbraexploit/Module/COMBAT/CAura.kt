package hedgegod.bbra.bbraexploit.Module.COMBAT

import hedgegod.bbra.bbraexploit.BBraExploit
import hedgegod.bbra.bbraexploit.Module.Module
import hedgegod.bbra.bbraexploit.utils.CrystalUtil
import hedgegod.bbra.bbraexploit.utils.EntityUtil
import hedgegod.bbra.bbraexploit.utils.MainUtils
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import org.lwjgl.input.Keyboard
import yea.hedgegod.clickgui.Setting

class CAura : Module {

    constructor() : super("CAura", Keyboard.KEY_M, Module.Category.COMBAT) {

        var options:ArrayList<String> = ArrayList<String>()

        options.add("OffHand")
        options.add("MainHand")

        BBraExploit.instance.sManager.rSetting(Setting("Hand", this, options, "Hand"))
        BBraExploit.instance.sManager.rSetting(Setting("PlaceSwing", this, true))
        BBraExploit.instance.sManager.rSetting(Setting("BreakSwing", this, false))
        BBraExploit.instance.sManager.rSetting(Setting("Range", this, 5.0, 2.0, 6.0, true))
        BBraExploit.instance.sManager.rSetting(Setting("MultiPlace", this, 2.0, 1.0, 10.0, true))
        BBraExploit.instance.sManager.rSetting(Setting("Rotate", this, false))
    }

    //////////////////////////////// vars for stuff
    var positions = mutableListOf<BlockPos>()

    @SubscribeEvent
    fun doCrystalAura(event: TickEvent.ServerTickEvent) {

        var target:EntityPlayer? = getTarget(BBraExploit.instance.sManager.getSettingByName(this.name, "Range").valDouble.toInt())

        if (target != null) {
            getPos()
            doPlace()
            doBreak()
        }
    }

    private fun doPlace() {
        try {
            for (i in 0 until BBraExploit.instance.sManager.getSettingByName(this.name, "MultiPlace").valDouble.toInt() - 1) {
                CrystalUtil.placeCrystal(positions[i], if (BBraExploit.instance.sManager.getSettingByName(this.name, "Hand").valString == "OffHand") EnumHand.OFF_HAND else EnumHand.MAIN_HAND, BBraExploit.instance.sManager.getSettingByName(this.name, "PlaceSwing").valBoolean, BBraExploit.instance.sManager.getSettingByName(this.name, "Rotate").valBoolean)  // place on block
            }
        } catch (e: Exception) {
        }
    }

    private fun doBreak() {
        try {
            for (i in MainUtils.getCrystals(BBraExploit.instance.sManager.getSettingByName(this.name, "Range").valDouble.toFloat())) {
                EntityUtil.attackEntity(i, !BBraExploit.instance.sManager.getSettingByName(this.name, "BreakSwing").valBoolean)
            }
        } catch (e: Exception) {
        }

    }

    private fun getTarget(range: Int): EntityPlayer? {
        try {
            return MainUtils.getEnemyPlayer(range.toDouble())

        } catch (e: Exception) {
        }
        return null
    }

    private fun getPos() {
        positions = CrystalUtil.possiblePlacePositions(BBraExploit.instance.sManager.getSettingByName(this.name, "Range").valDouble.toFloat(), false, false)
    }

}