package hedgegod.bbra.bbraexploit.Module.COMBAT

import hedgegod.bbra.bbraexploit.BBraExploit
import hedgegod.bbra.bbraexploit.Module.Module
import hedgegod.bbra.bbraexploit.event.events.MoveEvent
import hedgegod.bbra.bbraexploit.utils.ChatUtil
import hedgegod.bbra.bbraexploit.utils.CrystalUtil
import hedgegod.bbra.bbraexploit.utils.MainUtils.*
import net.minecraft.client.entity.EntityPlayerSP
import net.minecraft.entity.ai.EntityMoveHelper
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import net.minecraftforge.fml.relauncher.Side
import net.minecraftforge.fml.relauncher.SideOnly
import org.lwjgl.input.Keyboard
import kotlin.math.ceil


class CrystalAura : Module("Crystal Aura", Keyboard.KEY_M, Category.COMBAT) {

    private val rotate = false
    private val swing = false
    val breakDelay = 0
    private val range = 5
    private val offhand = true
    private val damage = 6.0f;
    private val ignoreSelf = false
    val multiplace: Int = 1

    fun main(args: Array<String>) {
        getPositions()
    }


    public val hand = if (offhand) EnumHand.OFF_HAND else EnumHand.MAIN_HAND
    public var target: EntityPlayerSP = getEnemyPlayer(range.toDouble()) as EntityPlayerSP
    private var prevTargetPos: Array<Int> = arrayOf(
            ceil(target.posX).toInt(),
            ceil(target.posY).toInt(),
            ceil(target.posZ).toInt()
    )

    private var possibleCrystalsPos: MutableCollection<BlockPos> = mutableListOf()
    private var targetBlocks: MutableCollection<BlockPos> = mutableListOf()


    @SubscribeEvent
    fun doPlace(e: TickEvent.ServerTickEvent) {
        if (target.getDistance(mc.player) > range) getEnemyPlayer(range.toDouble())
        /////////////////////////////////
        for (i in 1..multiplace) {
            CrystalUtil.placeCrystal(targetBlocks.elementAt(i), hand, rotate, swing)
            ChatUtil.sendMessage("Place crystal")
            doBreak(e)
        }
    }

    @SubscribeEvent
    fun doBreak(e: TickEvent.ServerTickEvent) {
        for (i in getCrystals(this.range.toFloat())) {
            attack(i, hand)
            ChatUtil.sendMessage("Broke crystal")
        }
    }

    ////////////////////////// utils block

    private fun getGoodPlace() {
        for (i in 1 until multiplace) {
            if (CrystalUtil.calculateDamage(possibleCrystalsPos.elementAt(i), target, ignoreSelf) >= damage) {
                targetBlocks.add(possibleCrystalsPos.elementAt(i))
                ChatUtil.sendMessage("New final place pos")
            }
        }
    }

    @SubscribeEvent
    private fun catchPlayerMove(e: TickEvent.PlayerTickEvent) {
        if (ceil(target.posX).toInt() != prevTargetPos[0] ||
                ceil(target.posY).toInt() != prevTargetPos[1] ||
                ceil(target.posZ).toInt() != prevTargetPos[2]) {
            getPositions()
            getGoodPlace()
            ChatUtil.sendMessage("Player changed position")
            prevTargetPos = arrayOf(target.posX.toInt(), target.posY.toInt(), target.posZ.toInt())
        }
    }

    fun getPositions() {
        for (i in -range until range) {
            for (j in -range until range) {
                possibleCrystalsPos.add(BlockPos(i + target.posX, target.posY, j + target.posZ))
                ChatUtil.sendMessage("New possibleCrystalsPos")
            }
        }
    }
}


