package hedgegod.bbra.bbraexploit.Module.COMBAT

import hedgegod.bbra.bbraexploit.BBraExploit
import hedgegod.bbra.bbraexploit.Module.Module
import hedgegod.bbra.bbraexploit.event.events.MoveEvent
import hedgegod.bbra.bbraexploit.utils.ChatUtil
import hedgegod.bbra.bbraexploit.utils.CrystalUtil
import hedgegod.bbra.bbraexploit.utils.MainUtils.*
import net.minecraft.client.entity.EntityPlayerSP
import net.minecraft.entity.ai.EntityMoveHelper
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.PlayerEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import net.minecraftforge.fml.relauncher.Side
import net.minecraftforge.fml.relauncher.SideOnly
import org.lwjgl.input.Keyboard
import kotlin.math.ceil

class CrystalAura : Module {


    constructor() : super("CAura", Keyboard.KEY_M, Module.Category.COMBAT)

    private val rotate = false
    private val swing = false
    private val breakDelay = 0
    private val range = 5
    private val offhand = true
    private val damage = 6.0f;
    private val ignoreSelf = false
    val multiplace: Int = 1

//    fun main(args: Array<String>) {
//        getPositions()
//    }

    public val hand = if (offhand) EnumHand.OFF_HAND else EnumHand.MAIN_HAND

    public lateinit var target: EntityPlayer
    private var prevTargetPos = mutableListOf<Int>()

    private var possibleCrystalsPos: MutableCollection<BlockPos> = mutableListOf()
    private var targetBlocks: MutableCollection<BlockPos> = mutableListOf()

    @SubscribeEvent
    fun onJoinedWorld(e: PlayerEvent.PlayerRespawnEvent){
        try {
            target = getEnemyPlayer(range.toDouble())
        }catch (e:Exception){
            BBraExploit.logger.debug("Some CA error idk")
        }
    }

    @SubscribeEvent
    fun doPlace(e: TickEvent.PlayerTickEvent) {
        try {
            if (target.getDistance(mc.player) > range) getEnemyPlayer(range.toDouble())
            /////////////////////////////////
            for (i in 1..multiplace) {
                if (!targetBlocks.isEmpty()) {
                    CrystalUtil.placeCrystal(targetBlocks.elementAt(i), hand, rotate, swing)
                    doBreak(e)
                }
                BBraExploit.logger.debug("Place crystal")
            }
        } catch (e: Exception) {
            BBraExploit.logger.error("Some CA error idk")
        }

    }


    @SubscribeEvent
    fun doBreak(e: TickEvent.PlayerTickEvent) {
        try {
            for (i in getCrystals(this.range.toFloat())) {
                attack(i, hand)
                BBraExploit.logger.debug("Broke crystal")
            }
        } catch (e: Exception) {
            BBraExploit.logger.error("Some CA error idk")
        }
    }


    //////////////////////////
    private fun getGoodPlace() {
        try {
            for (i in 1 until multiplace) {
                if (CrystalUtil.calculateDamage(possibleCrystalsPos.elementAt(i), target, ignoreSelf) >= damage) {
                    targetBlocks.add(possibleCrystalsPos.elementAt(i))
                    BBraExploit.logger.debug("New final place pos")
                }
            }
        } catch (e: Exception) {
            BBraExploit.logger.error("Some CA error idk")
        }
    }

//    @SubscribeEvent
//    private fun catchPlayerMove(e: TickEvent.PlayerTickEvent) {
//    try{
//        if (ceil(target.posX).toInt() != prevTargetPos[0] ||
//                ceil(target.posY).toInt() != prevTargetPos[1] ||
//                ceil(target.posZ).toInt() != prevTargetPos[2]) {
//            getPositions()
//            getGoodPlace()
//            BBraExploit.logger.debug("Player changed position")
//            prevTargetPos = mutableListOf(target.posX.toInt(), target.posY.toInt(), target.posZ.toInt())
//        }
//    }catch (e:Exception) {BBraExploit.logger.error("Some CA error idk")}
//    }

    fun getPositions() {
        try {
            for (i in -range until range) {
                for (j in -range until range) {
                    possibleCrystalsPos.add(BlockPos(i + target.posX, target.posY, j + target.posZ))
                    BBraExploit.logger.debug("New possibleCrystalsPos")
                }
            }
        } catch (e: Exception) {
            BBraExploit.logger.error("Some CA error idk")
        }
    }
}