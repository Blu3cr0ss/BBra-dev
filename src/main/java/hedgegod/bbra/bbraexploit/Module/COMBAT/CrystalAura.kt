package hedgegod.bbra.bbraexploit.Module.COMBAT

import hedgegod.bbra.bbraexploit.BBraExploit
import hedgegod.bbra.bbraexploit.Module.Module
import hedgegod.bbra.bbraexploit.utils.CrystalUtil
import hedgegod.bbra.bbraexploit.utils.MainUtils.*
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import org.lwjgl.input.Keyboard

class CrystalAura : Module {


    constructor() : super("CAura", Keyboard.KEY_M, Module.Category.COMBAT)

    private val rotate = false
    private val swing = false
    private val breakDelay = 0
    private val range = 5
    private val offhand = true
    private val damage = 6.0f;
    private val ignoreSelf = false
    val multiplace: Int = 1


    public val breakHand = EnumHand.MAIN_HAND
    public val placeHand = EnumHand.OFF_HAND

    public lateinit var target: EntityPlayer
    private var prevTargetPos = mutableListOf<Int>()

    private var possibleCrystalsPos: MutableCollection<BlockPos> = mutableListOf()
    private var targetBlocks: MutableCollection<BlockPos> = mutableListOf()


    @SubscribeEvent
    fun doPlace(e: TickEvent.ServerTickEvent) {
        try {
            target = getEnemyPlayer(range.toDouble())
                for (i in 0..multiplace) {
                    if (!targetBlocks.isEmpty()) {
                        CrystalUtil.placeCrystal(targetBlocks.elementAt(i), placeHand, rotate, swing)
                    }else{
                        getPositions()
                        getGoodPlace()
                        CrystalUtil.placeCrystal(targetBlocks.elementAt(i), placeHand, rotate, swing)
                    }
                    BBraExploit.logger.debug("Place crystal")
                }

                target = getEnemyPlayer(range.toDouble())

            BBraExploit.logger.debug(possibleCrystalsPos)
            BBraExploit.logger.debug(targetBlocks)

        } catch (e: Exception) {

            BBraExploit.logger.error("DoPlace error")
//            BBraExploit.logger.debug(target)
            BBraExploit.logger.debug(possibleCrystalsPos)
            BBraExploit.logger.debug(targetBlocks)
        }

    }


    @SubscribeEvent
    fun doBreak(e: TickEvent.ServerTickEvent) {
        try {
            for (i in getCrystals(this.range.toFloat())) {
                attack(i, breakHand)
                BBraExploit.logger.debug("Broke crystal")
            }
        } catch (e: Exception) {
            BBraExploit.logger.error("DoBreak error")
        }
    }


    //////////////////////////
    private fun getGoodPlace() {
        try {
            for (i in 0 until multiplace) {
                if (CrystalUtil.calculateDamage(possibleCrystalsPos.elementAt(i), target, ignoreSelf) >= damage) {
                    BBraExploit.logger.debug(CrystalUtil.calculateDamage(possibleCrystalsPos.elementAt(i), target, ignoreSelf))
                    targetBlocks.add(possibleCrystalsPos.elementAt(i))
                    BBraExploit.logger.debug("New final place pos")
                }
            }
            BBraExploit.logger.debug("good positions " + targetBlocks)
        } catch (e: Exception) {
            BBraExploit.logger.error("GetGoodPlace error")
        }
    }


    fun getPositions() {
        try {
            for (i in -range until range) {
                for (j in -range until range) {
                    possibleCrystalsPos.add(BlockPos(i + target.posX, target.posY, j + target.posZ))
                }
            }
            possibleCrystalsPos.remove(BlockPos(target.posX, target.posY,target.posZ))
            BBraExploit.logger.debug("possible positions " + possibleCrystalsPos)
        } catch (e: Exception) {
            BBraExploit.logger.error("GetPosition error")
        }
    }
}