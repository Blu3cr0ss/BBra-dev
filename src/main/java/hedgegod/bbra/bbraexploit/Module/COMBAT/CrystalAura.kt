package hedgegod.bbra.bbraexploit.Module.COMBAT

import hedgegod.bbra.bbraexploit.Module.Module
import hedgegod.bbra.bbraexploit.utils.CrystalUtil
import hedgegod.bbra.bbraexploit.utils.MainUtils.*
import net.minecraft.client.entity.EntityPlayerSP
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import net.minecraftforge.fml.relauncher.Side
import net.minecraftforge.fml.relauncher.SideOnly
import org.lwjgl.input.Keyboard


class CrystalAura : Module("Crystal Aura", Keyboard.KEY_NONE, Category.COMBAT) {


    val breakDelay = 0
    val range = 5.5f
    val offhand = true
    var target: EntityPlayerSP = getEnemyPlayer(range.toDouble()) as EntityPlayerSP
    val damage = 6.0f;
    var possibleCrystalsPos = mutableListOf(
            BlockPos(target.posX + 1, target.posY, target.posZ),
            BlockPos(target.posX + 2, target.posY, target.posZ),
            BlockPos(target.posX - 1, target.posY, target.posZ),
            BlockPos(target.posX - 2, target.posY, target.posZ),
            BlockPos(target.posX, target.posY, target.posZ + 1),
            BlockPos(target.posX, target.posY, target.posZ + 2),
            BlockPos(target.posX, target.posY, target.posZ - 1),
            BlockPos(target.posX, target.posY, target.posZ - 2),
            BlockPos(target.posX + 1, target.posY, target.posZ + 1),
            BlockPos(target.posX + 2, target.posY, target.posZ + 2),
            BlockPos(target.posX - 1, target.posY, target.posZ - 1),
            BlockPos(target.posX - 2, target.posY, target.posZ - 2),
            BlockPos(target.posX + 1, target.posY, target.posZ - 1),
            BlockPos(target.posX - 1, target.posY, target.posZ + 1),
            BlockPos(target.posX - 2, target.posY, target.posZ + 2),
            BlockPos(target.posX + 2, target.posY, target.posZ - 2),
            BlockPos(target.posX + 2, target.posY, target.posZ - 1),
            BlockPos(target.posX + 2, target.posY, target.posZ + 1),
            BlockPos(target.posX + 1, target.posY, target.posZ + 2),
            BlockPos(target.posX - 1, target.posY, target.posZ - 2),
            BlockPos(target.posX - 1, target.posY, target.posZ - 2),
            BlockPos(target.posX - 2, target.posY, target.posZ - 1),
            BlockPos(target.posX - 1, target.posY, target.posZ + 2),
            BlockPos(target.posX - 2, target.posY, target.posZ + 1)
    )


    @SubscribeEvent
    fun doPlace() {
        if (target.getDistance(mc.player) > range) getEnemyPlayer(range.toDouble())
        /////////////////////////////////

    }

    @SubscribeEvent
    fun doBreak(e: TickEvent.ServerTickEvent) {
        for (i in getCrystals(this.range)) {
            attack(i,
                    if (offhand) EnumHand.OFF_HAND else EnumHand.MAIN_HAND
            )
        }
    }

    ////////////////////////// utils block
    @SideOnly(Side.CLIENT)
    private fun placeGhostCrystal() {
        var cr: EntityEnderCrystal
        var crId = 0
        for (i in 0 until possibleCrystalsPos.size - 1) {
            crId = i * -3
            cr = EntityEnderCrystal(mc.world, possibleCrystalsPos[i].x.toDouble(),
                    possibleCrystalsPos[i].y.toDouble(),
                    possibleCrystalsPos[i].z.toDouble())
            mc.world.addEntityToWorld(crId, cr)
            if (CrystalUtil.calculateDamage(cr, target, false) >= damage) {
                mc.world.removeEntityFromWorld(crId)
                CrystalUtil.placeCrystal(possibleCrystalsPos[i],
                        if (offhand) EnumHand.OFF_HAND else EnumHand.MAIN_HAND,
                        false,
                        false
                )
                attack(cr)
            }else mc.world.removeEntityFromWorld(crId)
        }
    }
}