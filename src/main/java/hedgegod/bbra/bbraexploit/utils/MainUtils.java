package hedgegod.bbra.bbraexploit.utils;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import hedgegod.bbra.bbraexploit.utils.other.FriendsManager;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import org.jetbrains.annotations.NotNull;


public class MainUtils {

    private static Minecraft mc = Minecraft.getMinecraft();


    public static float[] rotations(Entity target) {    // Look to player
        double x = target.posX - mc.player.posX;
        double y = target.posY - (mc.player.posY + target.getEyeHeight()/3);
        double z = target.posZ - mc.player.posZ;

        double u = MathHelper.sqrt(x * x + z * z);

        float u2 = (float) (MathHelper.atan2(z, x) * (180D / Math.PI) - 90.0F); // yaw
        float u3 = (float) (-MathHelper.atan2(y, u) * (180D / Math.PI)); // pitch



        return new float[]{u2, u3};
    }

    public static float getUrActualYaw() {
        double actualYaw = mc.player.rotationYaw - (360 * Math.floor(mc.player.rotationYaw / 360));
        return (float) actualYaw;
    }

    public static float getTargetActualYaw(Entity target) {
        double actualTargetYaw = rotations(target)[0] - (360 * Math.floor(rotations(target)[0] / 360));
        return (float) actualTargetYaw;
    }

    public static void rotateLegit(Entity target) {

        double actualYaw = mc.player.rotationYaw - (360 * Math.floor(mc.player.rotationYaw / 360));
        double actualTargetYaw = rotations(target)[0] - (360 * Math.floor(rotations(target)[0] / 360));


        // Debug msgs
   	ChatUtil.sendMessage("Target Yaw is " + actualTargetYaw);
   	ChatUtil.sendMessage("Ur Yaw is " + actualYaw);

   	if (actualYaw - actualTargetYaw > 29 || actualTargetYaw - actualYaw < 29) {
   		ChatUtil.debugMsg(""+actualYaw+ " " + actualTargetYaw);

   		actualYaw -= 16;

   	}
   	else if (actualYaw - actualTargetYaw < 360-49){

   		actualYaw += 16;

   	}else {
   		actualYaw = actualTargetYaw;
   	}

        int ifPlus = (int) (actualTargetYaw + 360-actualYaw);
        int ifMinus = (int) (actualYaw-actualTargetYaw);

   	if (actualTargetYaw - actualYaw < 29 || actualYaw - actualTargetYaw < 29) {
   		actualYaw = actualTargetYaw;
   	}else {

   	if(ifPlus ==  ifMinus) {
   		actualYaw += 16;
   	}else
   	if(ifPlus > ifMinus) {
   		actualYaw -= 16;
   	}else
   	if(ifPlus < ifMinus) {
   		actualYaw += 16;
   	}
       }

        mc.player.rotationYaw = (float) actualYaw;              /////// Tak i ne dodelal (ya ustal)
        mc.player.rotationPitch = rotations(target)[1];
    }


    public static void attack(Entity target) {
        mc.playerController.attackEntity(mc.player, target);
        mc.player.swingArm(EnumHand.MAIN_HAND);
        mc.player.resetCooldown();
    }
    public static void attack(Entity target, EnumHand hand) {
        mc.playerController.attackEntity(mc.player, target);
        mc.player.swingArm(hand);
        mc.player.resetCooldown();
    }
    public static EntityPlayer getEnemyPlayer(double range) {


        EntityPlayer target = mc.world.playerEntities.stream()
                .filter(entityPlayer -> entityPlayer != mc.player)
                .min(Comparator.comparing(entityPlayer ->entityPlayer.getDistance(mc.player)))
                .filter(entityPlayer -> entityPlayer.getDistance(mc.player) <= range)
                .filter(entityPlayer -> !entityPlayer.getName().equalsIgnoreCase(""))			// checking if its bot
                .filter(entityPlayer -> entityPlayer.getCustomNameTag() == "")
                .filter(entityPlayer -> !FriendsManager.isFriend(entityPlayer.getName()))
                .orElse(null);



        return target;

    }

	/*public boolean getValidPlayer(EntityPlayer entity) {

		entity.filter(entityPlayer -> entityPlayer != mc.player)
		.min(Comparator.comparing(entityPlayer ->entityPlayer.getDistance(mc.player)))
		.filter(entityPlayer -> entityPlayer.getName() != null)
		.filter(entityPlayer -> entityPlayer.getCustomNameTag() == "")
		.orElse(null);

		if (entity) {

		}

		return true;

	}*/

    public static List<EntityPlayer> allEntities() {
        return mc.world.playerEntities;
    }


    public static List<EntityEnderCrystal> getCrystals(float range){
        List<EntityEnderCrystal> crystals = new ArrayList<>();
        for (Entity e : mc.world.loadedEntityList){
            if (e instanceof EntityEnderCrystal && e.getDistance(mc.player) <= range){
                crystals.add((EntityEnderCrystal) e);
            }
        }
        return crystals;
    }




}