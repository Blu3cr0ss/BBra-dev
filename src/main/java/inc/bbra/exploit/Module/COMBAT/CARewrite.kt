package inc.bbra.exploit.Module.COMBAT

import inc.bbra.exploit.BBraExploit
import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.*
import inc.bbra.exploit.utils.*
import inc.bbra.exploit.utils.CrystalUtil.calculateDamage
import inc.bbra.exploit.utils.other.FriendsManager
import kotlinx.coroutines.*
import net.minecraft.entity.Entity
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.util.EnumHand
import net.minecraft.util.NonNullList
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard
import javax.annotation.Nonnull


class RewriteCA : Module("CA Rewrite", Keyboard.KEY_NONE, Category.COMBAT) {

    ////////////////////////////// DELAYS
    val pageDelays = PageSetting(this, "Delays")
    val placeDelay = IntSetting(this, "Place Delay", pageDelays, 0, 0, 10)
    val breakDelay = IntSetting(this, "Break Delay", pageDelays, 0, 0, 10)

    ////////////////////////////// RANGES
    val pageRanges = PageSetting(this, "Ranges")
    val placeRange = IntSetting(this, "Place Range", pageRanges, 5, 1, 7)
    val breakRange = IntSetting(this, "Break Range", pageRanges, 5, 1, 7)
    val targetRange = IntSetting(this, "Target Range", pageRanges, 12, 2, 32)
    val throughBlocks = BoolSetting(this, "Through Blocks", pageRanges, true)
    val rotate = BoolSetting(this, "Rotate", pageRanges, false)

    ///////////////////////////// DAMAGES
    val pageDamages = PageSetting(this, "Damages")
    val antiSuicide = BoolSetting(this, "Anti Suicide", pageDamages, true)
    val selfDamage = FloatSetting(this, "Self Damage", pageDamages, 8f, 1f, 16f)
    val placeDamage = FloatSetting(this, "Place Damage", pageDamages, 4f, 1f, 36f)
    val instaBreak = BoolSetting(this, "Insta Break", pageDamages, true)
    val breakDamage = FloatSetting(this, "Break Damage", pageDamages, 4f, 1f, 36f)
    val positioningMode = ModeSetting(this, "Positioning Mode", pageDamages, arrayListOf("Benefit", "Damage"))


    ///////////////////////////// HAND
    val pageHands = PageSetting(this, "Hands")
    val placeHand = ModeSetting(this, "Place Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val breakHand = ModeSetting(this, "Break Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val swing = BoolSetting(this, "Swing", pageHands, false)

    ///////////////////////////// HELPING
    val multiplace = IntSetting(this, "MultiPlace", 1, 1, 3)
    val helpingBlocks = BoolSetting(this, "Helping Blocks", true)
    val facePlace = BoolSetting(this, "FacePlace", false)
    val targeting = ModeSetting(this, "Targeting", arrayListOf("Health", "Range"))
    val shouldIgnore = BoolSetting(this, "ShouldIgnore", false)
    val breakMode = ModeSetting(this, "Break Mode", pageDamages, arrayListOf("Packet", "Normal"))


    /////////////////// stuff vars

    var target: EntityPlayer? = null
    var myCrystals = arrayListOf<EntityEnderCrystal>()
    var placePositions = mutableListOf<BlockPos>()


    // meter
    var placed: Int = 0
    var passed: Int = 0
    ////

    override fun onDisable() {
        if (passed != 0) {
            ChatUtil.sendMessage("speed is ${placed / passed}")
        }
        placed = 0
        passed = 0
        super.onDisable()
    }

    @SubscribeEvent
    fun onTick(e: PlayerTickEvent) {
        passed += 1
        doCA()
    }

    fun doCA() {
        if (findCrystalsInHotbar() == -1) {
            ChatUtil.sendMessage("No crystals!")
        } else {
            getTarget()
            taskPlace()
            taskBreak()
        }
    }

    fun taskPlace() {
        try {
            val hand = if (placeHand.`val` == "OFFHAND") EnumHand.OFF_HAND else EnumHand.MAIN_HAND
            getPositions()
            if (!facePlace.`val`) {   // If not faceplace
                placePositions.forEach {
                    if (rotate.`val`) CrystalUtil.rotateHead(
                        it.x.toDouble(),
                        it.y.toDouble(),
                        it.z.toDouble(),
                        mc.player
                    )

                    BlockUtil.placeCrystalOnBlock(it, hand, true)
                    ChatUtil.sendMessage("tried to place")
                    myCrystals = crystalsInWorld()
                }
                myCrystals.forEach {
                    placed += 1
                }
            } else {
                BBraExploit.logger.info("faceplace")
            }

            myCrystals.forEach {
                ChatUtil.sendMessage("crystal is ${it.posX}, ${it.posY}, ${it.posZ}")
            }
        } catch (e: Exception) {

        }
    }

    fun getPositions() {
        getPossibleCrystals()
        getBestCrystal()
    }

    fun getPossibleCrystals() {
        placePositions =
            (CrystalUtil.possiblePlacePositions(
                placeRange.`val`.toFloat(),
                true,
                false
            ))
        BBraExploit.logger.debug(placePositions)
    }

    fun getBestCrystal() {
        if (placePositions.isNotEmpty()) {
            ChatUtil.sendMessage("tried to get possible positions")
            for (i in 0 until multiplace.`val`) {
                val rn = if (positioningMode.`val` == "Benefit") {
                    placePositions.maxBy {
                        calculateDamage(it, target, shouldIgnore.`val`) - calculateDamage(
                            it,
                            mc.player,
                            shouldIgnore.`val`
                        )
                    }!!
                } else {
                    placePositions.maxBy {
                        calculateDamage(it, target, shouldIgnore.`val`)             // Max damage
                    }!!
                }
                if (calculateDamage(rn, target, shouldIgnore.`val`) >= placeDamage.`val`) {
                    placePositions.remove(BlockPos(rn.x + 1, rn.y, rn.z + 1))
                    placePositions.remove(BlockPos(rn.x - 1, rn.y, rn.z - 1))
                    placePositions.remove(BlockPos(rn.x - 1, rn.y, rn.z + 1))
                    placePositions.remove(BlockPos(rn.x + 1, rn.y, rn.z - 1))
                    placePositions.remove(BlockPos(rn.x + 1, rn.y, rn.z))
                    placePositions.remove(BlockPos(rn.x - 1, rn.y, rn.z - 1))
                    placePositions.remove(BlockPos(rn.x, rn.y, rn.z + 1))
                    placePositions.remove(BlockPos(rn.x, rn.y, rn.z - 1))
                } else {
                    placePositions.clear()
                    break
                }
                if (placePositions.size == multiplace.`val` - 1) break
            }
        }
        BBraExploit.logger.debug(placePositions)
    }

    fun getTarget() {
        val possibleTargets = mc.world.playerEntities.filter { player ->
            player.getDistance(mc.player) <= targetRange.`val`
        }.filter { player ->
            player.name != mc.player.name
        }
        if (targeting.`val` == "Range") {
            target = possibleTargets.minBy {
                it.getDistance(mc.player)                                        // Min distance
            }
        } else {
            target = possibleTargets.minBy {
                it.health                         // Min health
            }
        }
    }

    fun taskBreak() {
        if (!instaBreak.`val`) {
            if (!antiSuicide.`val`) {
                myCrystals.forEach {
                    EntityUtil.attackEntity(
                        it,
                        swing.`val`,
                        breakMode.`val` == "Packet",
                        if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                    ) // Pretty simple yeah?
                    BBraExploit.logger.debug("Breaked at ${it.position}")
                }
            } else {
                myCrystals.forEach {
                    val dmg = calculateDamage(it.position, mc.player, shouldIgnore.`val`)
                    if (dmg <= selfDamage.`val` && dmg < mc.player.health) {

                        EntityUtil.attackEntity(
                            it,
                            swing.`val`,
                            breakMode.`val` == "Packet",
                            if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                        ) // Pretty simple yeah?
                        it.setDead()
                        BBraExploit.logger.debug("Breaked at ${it.position}")
                    }
                }
            }
        } else {
            crystalsInWorld().forEach {
                EntityUtil.attackEntity(
                    it,
                    swing.`val`,
                    breakMode.`val` == "Packet",
                    if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                ) // Pretty simple yeah?
                it.setDead()
                BBraExploit.logger.debug("Breaked at ${it.position}")
            }
        }
        placePositions.clear()
        myCrystals.clear()
    }

    private fun findCrystalsInHotbar(): Int {
        for (i in 0..8) {
            if (CAura.mc.player.inventory.getStackInSlot(i).item === Items.END_CRYSTAL) {
                return i
            }
        }
        return -1
    }

    private fun crystalsInWorld(): ArrayList<EntityEnderCrystal> {
        val crystals = ArrayList<EntityEnderCrystal>()
        if (!CAura.mc.world.loadedEntityList.isEmpty()) {
            //for (Entity e : mc.world.loadedEntityList) {
            for (i in CAura.mc.world.loadedEntityList.indices) {
                val e = CAura.mc.world.loadedEntityList[i]
                if (e is EntityEnderCrystal && (e.getDistance(mc.player) <= breakRange.`val`) && !e.isDead) crystals.add(
                    e
                )
            }
        }
        return crystals
    }
}