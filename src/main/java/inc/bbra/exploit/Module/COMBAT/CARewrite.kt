package inc.bbra.exploit.Module.COMBAT

import inc.bbra.exploit.BBraExploit
import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.*
import inc.bbra.exploit.utils.*
import inc.bbra.exploit.utils.CrystalUtil.calculateDamage
import kotlinx.coroutines.*
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.network.play.server.SPacketSpawnMob
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard


// TODO: END THIS SHIT
class RewriteCA : Module("CA Rewrite", Keyboard.KEY_NONE, Category.COMBAT) {
    ////////////////////////////// DELAYS
    val pageDelays = PageSetting(this, "Delays")
    val placeDelay = IntSetting(this, "Place Delay", pageDelays, 0, 0, 10)
    val breakDelay = IntSetting(this, "Break Delay", pageDelays, 0, 0, 10)

    ////////////////////////////// RANGES
    val pageRanges = PageSetting(this, "Ranges")
    val placeRange = IntSetting(this, "Place Range", pageRanges, 5, 1, 7)
    val breakRange = IntSetting(this, "Break Range", pageRanges, 5, 1, 7)
    val targetRange = IntSetting(this, "Target Range", pageRanges, 12, 2, 32)
    val rotate = BoolSetting(this, "Rotate", pageRanges, false)

    ///////////////////////////// DAMAGES
    val pageDamages = PageSetting(this, "Damages")
    val antiSuicide = BoolSetting(this, "Anti Suicide", pageDamages, true)
    val selfDamage = FloatSetting(this, "Self Damage", pageDamages, 8f, 1f, 16f)
    val placeDamage = FloatSetting(this, "Place Damage", pageDamages, 4f, 1f, 36f)
    val instaBreak = BoolSetting(this, "Insta Break", pageDamages, true)
    val breakDamage = FloatSetting(this, "Break Damage", pageDamages, 4f, 1f, 36f)
    val positioningMode = ModeSetting(this, "Positioning Mode", pageDamages, arrayListOf("Benefit", "Damage"))

    ///////////////////////////// HAND
    val pageHands = PageSetting(this, "Hands")
    val placeHand = ModeSetting(this, "Place Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val breakHand = ModeSetting(this, "Break Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val swing = BoolSetting(this, "Swing", pageHands, false)

    ///////////////////////////// HELPING
    val multiplace = IntSetting(this, "MultiPlace", 1, 1, 3)
    val helpingBlocks = BoolSetting(this, "Helping Blocks", true)
    val facePlace = BoolSetting(this, "FacePlace", false)
    val targeting = ModeSetting(this, "Targeting", arrayListOf("Health", "Range"))
    val breakMode = ModeSetting(this, "Break Mode", pageDamages, arrayListOf("Packet", "Normal"))

    /////////////////// stuff vars
    var target: EntityPlayer? = null
    var myCrystals = arrayListOf<EntityEnderCrystal>()
    var placePositions = mutableListOf<BlockPos>()
    var needReCalcPosition = true
    ///////////////////// catch entity move
//    var prevTickTargetPos:BlockPos?= null
//    var prevTickPlayerPos:BlockPos?= null

    @SubscribeEvent
    fun onTick(e: PlayerTickEvent) {
        doCA()
    }

    fun doCA() {
        if (findCrystalsInHotbar() != -1) {
            getTarget()
            if (target != null) {
//                onUpdateWalkingPlayer()
                taskPlace()
                taskBreak()
//                prevTickTargetPos = target?.position
//                prevTickPlayerPos = mc.player.position
            }
        }
    }

//    fun onUpdateWalkingPlayer() {
//        if (positioningMode.`val`.equals("Benefit")){
//            if (prevTickPlayerPos != mc.player.position || prevTickTargetPos != target?.position) {
//                needReCalcPosition = true
//            }
//        }else if (prevTickTargetPos != target?.position){
//            needReCalcPosition = true
//        }
//    }

    fun taskPlace() {
        val hand = if (placeHand.`val` == "OFFHAND") EnumHand.OFF_HAND else EnumHand.MAIN_HAND
//            if (needReCalcPosition){
//                getPositions()
//                needReCalcPosition = false
//            }
        getPositions()
        if (placePositions.isNotEmpty()) {
            if (!facePlace.`val`) {   // If not faceplace
                placePositions.forEach {
                    if (rotate.`val`) CrystalUtil.rotateHead(
                        it.x.toDouble(),
                        it.y.toDouble(),
                        it.z.toDouble(),
                        mc.player
                    )
                    CrystalUtil.placeCrystalOnBlock(it, hand, swing.`val`)
                    try {
                        myCrystals.add(
                            crystalsInWorld().first { crystal ->
                                crystal.position == it
                            }
                        )
                    }catch (e: Exception) {
                        ChatUtil.sendMessage("The most dumbas error in the world")
                    }
                }
            } else {
                BBraExploit.logger.info("faceplace")
            }
        }
    }

    fun getPositions() {
        val pos2set = arrayListOf<BlockPos>()
        val allPoses = ArrayList(CrystalUtil.possiblePlacePositions(placeRange.`val`.toFloat(), true, false))
        if (allPoses.isNotEmpty()) {
            if (positioningMode.`val`.equals("Damage")) {
                while (pos2set.size != multiplace.`val`) {
                    var dmg = 0f
                    var selfDmg = 0f
                    val what2add = allPoses.maxBy {
                        dmg = calculateDamage(it, target, false)
                        selfDmg = calculateDamage(it, mc.player, false)
                        dmg
                    }
                    if (antiSuicide.`val` && dmg >= placeDamage.`val` && selfDmg <= selfDamage.`val`) {
                        if (what2add != null) {
                            pos2set.add(what2add)
                        }
                    }
                    allPoses.remove(what2add)
                }
            } else {
                while (pos2set.size != multiplace.`val`) {
                    var dmg = 0f
                    var selfDmg = 0f
                    val what2add = allPoses.maxBy {
                        dmg = calculateDamage(it, target, false)
                        selfDmg = calculateDamage(it, mc.player, false)
                        dmg - selfDmg
                    }
                    if (antiSuicide.`val` && dmg >= placeDamage.`val` && selfDmg <= selfDamage.`val`) {
                        if (what2add != null) {
                            pos2set.add(what2add)
                        }
                    }
                    allPoses.remove(what2add)
                }
            }
            placePositions = pos2set
        }
    }


    fun getTarget() {
        val possibleTargets = mc.world.playerEntities.filter { player ->
            player.getDistance(mc.player) <= targetRange.`val`
        }.filter { player ->
            player.name != mc.player.name
        }
        if (targeting.`val` == "Range") {
            target = possibleTargets.minBy {
                it.getDistance(mc.player)                                        // Min distance
            }
        } else {
            target = possibleTargets.minBy {
                it.health                                                   // Min health
            }
        }
    }

    fun taskBreak() {
        if (myCrystals.isNotEmpty()) {
            if (!instaBreak.`val`) {
                if (!antiSuicide.`val`) {
                    myCrystals.forEach {
                        if (!it.isDead) {
                            EntityUtil.attackEntity(
                                it,
                                swing.`val`,
                                breakMode.`val` == "Packet",
                                if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                            )
                        }
                    }
                } else {
                    myCrystals.forEach {
                        if (!it.isDead) {
                            val dmg = calculateDamage(it.position, mc.player, false)
                            if (dmg < mc.player.health) {
                                EntityUtil.attackEntity(
                                    it,
                                    swing.`val`,
                                    breakMode.`val` == "Packet",
                                    if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                                )
                                it.setDead()
                            }
                        }
                    }
                }
            } else {
                crystalsInWorld().forEach {
                    if (!it.isDead) {
                        EntityUtil.attackEntity(
                            it,
                            swing.`val`,
                            breakMode.`val` == "Packet",
                            if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
                        )
                        it.setDead()
                    }
                }
            }
        }
        placePositions.clear()
        myCrystals.clear()
    }

    private fun findCrystalsInHotbar(): Int {
        for (i in 0..8) {
            if (CAura.mc.player.inventory.getStackInSlot(i).item === Items.END_CRYSTAL) {
                return i
            }
        }
        return -1
    }

    private fun crystalsInWorld(): ArrayList<EntityEnderCrystal> {
        val crystals = ArrayList<EntityEnderCrystal>()
        if (mc.world.loadedEntityList.isEmpty()) {
            for (i in mc.world.loadedEntityList.indices) {
                val e = mc.world.loadedEntityList[i]
                if (e is EntityEnderCrystal && (e.getDistance(mc.player) <= breakRange.`val`) && !e.isDead) crystals.add(
                    e
                )
            }
        }
        return crystals
    }
}