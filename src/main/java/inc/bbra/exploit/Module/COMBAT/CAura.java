package inc.bbra.exploit.Module.COMBAT;

import inc.bbra.exploit.BBraExploit;
import inc.bbra.exploit.Module.Module;
import inc.bbra.exploit.utils.*;
import inc.bbra.exploit.utils.other.FriendsManager;
import inc.bbra.exploit.utils.other.MathsUtil;
import inc.bbra.newclickgui.Setting;
import jdk.nashorn.internal.ir.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.jetbrains.annotations.NotNull;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

public class CAura extends Module {
    public CAura(){
        super("CAura", Keyboard.KEY_NONE, Category.COMBAT);

        ArrayList<String> options = new ArrayList();

        options.add("Mainhand");
        options.add("Offhand");

        BBraExploit.instance.sManager.rSetting(new Setting("Target Range", this, 15, 8, 50, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Armor Check", this, false));

        BBraExploit.instance.sManager.rSetting(new Setting("Min DMG", this, 8, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Max self DMG", this, 7.5, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("MultiPlace", this, 1, 1, 12, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Delay", this, 2, 0, 20, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Hand", this, options, "Hand"));
        BBraExploit.instance.sManager.rSetting(new Setting("Attack Range", this,  5, 2, 6, false));
        BBraExploit.instance.sManager.rSetting(new Setting("idk wtf", this, true));
    }

    //vars from gui
    private double range = 15;
    private boolean armorCheck = false;

    private double minDmg =  8;
    private double maxSelfD = 7.5;
    private int multiplace = 1;
    private int delay = 2;
    private EnumHand hand = EnumHand.MAIN_HAND;
    private double attackRange = 5;
    private boolean shouldIgnore = true;

    //CA mechanism vars
    static Minecraft mc = Minecraft.getMinecraft();
    private EntityPlayer target = null;
    private ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>();
    private short ticks = 0;

    //mechanism

    @SubscribeEvent
    public void onTick(TickEvent.PlayerTickEvent e) throws Exception {
        this.refreshValues();
        this.doCA();
    }

    private void refreshValues(){
        this.range = BBraExploit.instance.sManager.getSettingByName(this.name, "Target Range").getValDouble();
        this.armorCheck = BBraExploit.instance.sManager.getSettingByName(this.name, "Armor Check").getValBoolean();
        this.minDmg = BBraExploit.instance.sManager.getSettingByName(this.name, "Min DMG").getValDouble();
        this.maxSelfD = BBraExploit.instance.sManager.getSettingByName(this.name, "Max self DMG").getValDouble();
        this.multiplace = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "MultiPlace").getValDouble();
        this.delay = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "Delay").getValDouble();
        this.hand = BBraExploit.instance.sManager.getSettingByName(this.name, "Hand").getValString().equals("Mainhand") ? EnumHand.MAIN_HAND:EnumHand.OFF_HAND;
        this.attackRange = BBraExploit.instance.sManager.getSettingByName(this.name, "Attack Range").getValDouble();
        this.shouldIgnore = BBraExploit.instance.sManager.getSettingByName(this.name, "idk wtf").getValBoolean();

        //part2
        try {
            this.target = this.getTarget();
        } catch (Exception e) {
            ChatUtil.sendMessage("Failed to get target");
        }
        this.crystals = this.getCrystals();
        this.ticks ++;
    }

    private void doCA() throws Exception {
        if(this.isAllowedByTicks() && !(this.target == null) && !(mc.player.isDead)) {
            //ChatUtil.sendMessage("Trying...");
            this.placeCs();
            ChatUtil.sendMessage("Calling break func");
            this.breakCs();
        }
    }

    private boolean isAllowedByTicks(){
        if (this.delay == 0 || (this.delay > 0 && this.ticks != 0 && this.ticks >= this.delay)){
            this.ticks = 0;
            return true;
        }
        else return false;
    }

    private void placeCs(){
        short crystalsPlaced = 0;
        if(!(this.target == null)){
            List<BlockPos> possibles = CrystalUtil.possiblePlacePositions((float)this.range, false, false);
            for(BlockPos pos : possibles){
                if (crystalsPlaced < multiplace &&
                mc.player.getHeldItem(this.hand).getItem().equals(Items.END_CRYSTAL) &&
                CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= this.minDmg &&
                CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore) <= this.maxSelfD &&
                CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore)){
                    BlockUtil.placeCrystalOnBlock(pos, this.hand, true);
                    crystalsPlaced++;
                }
            }
        }
    }
    private void breakCs() throws Exception {
        if (!(this.crystals.isEmpty())) {
            ChatUtil.sendMessage("Scanning for crystals");
            for (EntityEnderCrystal crystal : this.crystals) {
                if (/*CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= this.minDmg &&
                        CrystalUtil.calculateDamage(crystal.getPosition(), mc.player, this.shouldIgnore) <= this.maxSelfD &&
                        CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(this.crystals.get(0).getPosition(), mc.player, this.shouldIgnore) && */
                        CrystalUtil.calculateDamage(crystal.getPosition(), mc.player, false) <= mc.player.getHealth() + mc.player.getAbsorptionAmount() &&
                        Minecraft.getMinecraft().player.getCooledAttackStrength(0) == 1) {
                    ChatUtil.sendMessage("Attempting to break..");
                    mc.playerController.updateController();
                    mc.playerController.attackEntity(mc.player, crystal);
                    mc.player.swingArm(this.hand);
                    this.crystals.clear();
                    return;
                }
            }
        }
    }

    private ArrayList<EntityEnderCrystal> getCrystals(){
        ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>();
        if(!mc.world.loadedEntityList.isEmpty()) {
            for (Entity e : mc.world.loadedEntityList) {
                if (e instanceof EntityEnderCrystal && (e.getDistance(mc.player) <= this.attackRange) && !(e.isDead))
                    crystals.add((EntityEnderCrystal) e);
            }
        }
        return crystals;
    }

    private EntityPlayer getTarget() throws Exception{
        if (this.armorCheck){
            for(EntityPlayer player : mc.world.playerEntities){
                if (player.getTotalArmorValue() > 0 && !player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range)
                    return player;
            }
        }
        else {
            for(EntityPlayer player : mc.world.playerEntities){
                if (!player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range)
                    return player;
            }
        }
        return null;
    }
}