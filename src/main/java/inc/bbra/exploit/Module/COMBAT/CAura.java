package inc.bbra.exploit.Module.COMBAT;

import inc.bbra.exploit.BBraExploit;
import inc.bbra.exploit.Module.Module;
import inc.bbra.exploit.clickgui.modules.settings.*;
import inc.bbra.exploit.utils.*;
import inc.bbra.exploit.utils.other.FriendsManager;
import inc.bbra.exploit.utils.other.MathsUtil;
import inc.bbra.newclickgui.Setting;
import jdk.nashorn.internal.ir.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.jetbrains.annotations.NotNull;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

public class CAura extends Module {
    public PageSetting ranges = new PageSetting(this, "Ranges");
    public PageSetting damages = new PageSetting(this, "Damages");
    public PageSetting delays = new PageSetting(this, "Delays");
    public PageSetting faceplace = new PageSetting(this, "Faceplace");

    public FloatSetting placeRange = new FloatSetting(this, "Place Range", ranges, 6f, 1f, 8f);
    public FloatSetting breakRange = new FloatSetting(this, "Break Range", ranges, 6f, 1f, 8f);

    public FloatSetting minDmg_ = new FloatSetting(this, "Min Dmg", damages, 7f, 0f, 36f);
    public FloatSetting maxSelfDmg = new FloatSetting(this, "Max Self Dmg", damages, 5f, 0f, 36f);

    public IntSetting placeDelay = new IntSetting(this, "Place Delay", delays, 0, 0, 5);
    public IntSetting breakDelay = new IntSetting(this, "Break Delay", delays, 0, 0, 5);

    public IntSetting FPHP = new IntSetting(this, "FP HP", faceplace, 14, 1, 36);
    public FloatSetting FPDmg = new FloatSetting(this, "FP Dmg", faceplace, 0.5f, 0.1f, 3f);

    public ModeSetting logic = new ModeSetting(this, "Logic", getLogicModes( ));
    public ModeSetting placeHand = new ModeSetting(this, "Place Hand", getHandsModes( ));
    public ModeSetting breakHand = new ModeSetting(this, "Break Hand", getHandsModes( ));

    public BoolSetting helping = new BoolSetting(this, "Helping Blocks", false);

    private ArrayList<String> getLogicModes() {
        ArrayList<String> modes = new ArrayList<String>( );
        modes.add("place->break");
        modes.add("break->place");
        return modes;
    }

    private ArrayList<String> getHandsModes() {
        ArrayList<String> modes = new ArrayList<String>( );
        modes.add("Mainhand");
        modes.add("Offhand");
        return modes;
    }

    public CAura() {
        super("CAura", Keyboard.KEY_NONE, Category.COMBAT);

        ArrayList<String> options = new ArrayList( );

        options.add("Mainhand");
        options.add("Offhand");

        BBraExploit.instance.sManager.rSetting(new Setting("Target Range", this, 15, 8, 50, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Armor Check", this, false));

        BBraExploit.instance.sManager.rSetting(new Setting("Min DMG", this, 8, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Max self DMG", this, 7.5, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("MultiPlace", this, 1, 1, 12, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Delay", this, 2, 0, 20, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Hand", this, options, "Hand"));
        BBraExploit.instance.sManager.rSetting(new Setting("Attack Range", this, 5, 2, 6, false));
        BBraExploit.instance.sManager.rSetting(new Setting("idk wtf", this, true));
    }

    //vars from gui
    private double range = 15;
    private boolean armorCheck = false;

    private double minDmg = 8;
    private double maxSelfD = 7.5;
    private int multiplace = 1;
    private int delay = 2;
    private EnumHand hand = EnumHand.MAIN_HAND;
    private double attackRange = 5;
    private boolean shouldIgnore = true;

    //CA mechanism vars
    static Minecraft mc = Minecraft.getMinecraft( );
    private EntityPlayer target = null;
    private ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>( );
    private short ticks = 0;

    //mechanism

    @SubscribeEvent
    public void onTick(TickEvent.PlayerTickEvent e) throws Exception {
        this.refreshValues( );
        this.doCA( );
    }

    private void refreshValues() {
        this.range = BBraExploit.instance.sManager.getSettingByName(this.name, "Target Range").getValDouble( );
        this.armorCheck = BBraExploit.instance.sManager.getSettingByName(this.name, "Armor Check").getValBoolean( );
        this.minDmg = BBraExploit.instance.sManager.getSettingByName(this.name, "Min DMG").getValDouble( );
        this.maxSelfD = BBraExploit.instance.sManager.getSettingByName(this.name, "Max self DMG").getValDouble( );
        this.multiplace = (int) BBraExploit.instance.sManager.getSettingByName(this.name, "MultiPlace").getValDouble( );
        this.delay = (int) BBraExploit.instance.sManager.getSettingByName(this.name, "Delay").getValDouble( );
        this.hand = BBraExploit.instance.sManager.getSettingByName(this.name, "Hand").getValString( ).equals("Mainhand") ? EnumHand.MAIN_HAND : EnumHand.OFF_HAND;
        this.attackRange = BBraExploit.instance.sManager.getSettingByName(this.name, "Attack Range").getValDouble( );
        this.shouldIgnore = BBraExploit.instance.sManager.getSettingByName(this.name, "idk wtf").getValBoolean( );

        //part2
        try {
            this.target = this.getTarget( );
        } catch (Exception e) {
            ChatUtil.sendMessage("Failed to get target");
        }
        this.crystals = this.getCrystals( );
        this.ticks++;
    }

    private void doCA() throws Exception {
        if (this.isAllowedByTicks( ) && !(this.target == null) && !(mc.player.isDead)) {
            //ChatUtil.sendMessage("Trying...");
            this.placeCs( );
            ChatUtil.sendMessage("Calling break func");
            this.breakCs( );
        }
    }

    private boolean isAllowedByTicks() {
        if (this.delay == 0 || (this.delay > 0 && this.ticks != 0 && this.ticks >= this.delay)) {
            this.ticks = 0;
            return true;
        } else return false;
    }

    private void placeCs() {
        short crystalsPlaced = 0;
        if (!(this.target == null)) {
            List<BlockPos> possibles = CrystalUtil.possiblePlacePositions((float) this.range, false, false);
            for (BlockPos pos : possibles) {
                if (crystalsPlaced < multiplace &&
                        mc.player.getHeldItem(this.hand).getItem( ).equals(Items.END_CRYSTAL) &&
                        CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= this.minDmg &&
                        CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore) <= this.maxSelfD &&
                        CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore)) {
                    BlockUtil.placeCrystalOnBlock(pos, this.hand, true);
                    crystalsPlaced++;
                }
            }
        }
    }

    private void breakCs() throws Exception {
        if (!(this.crystals.isEmpty( ))) {
            ChatUtil.sendMessage("Scanning for crystals");
            for (EntityEnderCrystal crystal : this.crystals) {
                if (/*CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= this.minDmg &&
                        CrystalUtil.calculateDamage(crystal.getPosition(), mc.player, this.shouldIgnore) <= this.maxSelfD &&
                        CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(this.crystals.get(0).getPosition(), mc.player, this.shouldIgnore) && */
                        CrystalUtil.calculateDamage(crystal.getPosition( ), mc.player, false) <= mc.player.getHealth( ) + mc.player.getAbsorptionAmount( ) &&
                                Minecraft.getMinecraft( ).player.getCooledAttackStrength(0) == 1) {
                    ChatUtil.sendMessage("Attempting to break..");
                    mc.playerController.updateController( );
                    mc.playerController.attackEntity(mc.player, crystal);
                    mc.player.swingArm(this.hand);
                    this.crystals.clear( );
                    return;
                }
            }
        }
    }

    private ArrayList<EntityEnderCrystal> getCrystals() {
        ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>( );
        if (!mc.world.loadedEntityList.isEmpty( )) {
            for (Entity e : mc.world.loadedEntityList) {
                if (e instanceof EntityEnderCrystal && (e.getDistance(mc.player) <= this.attackRange) && !(e.isDead))
                    crystals.add((EntityEnderCrystal) e);
            }
        }
        return crystals;
    }

    private EntityPlayer getTarget() throws Exception {
        if (this.armorCheck) {
            for (EntityPlayer player : mc.world.playerEntities) {
                if (player.getTotalArmorValue( ) > 0 && !player.isDead && !FriendsManager.isFriend(player.getName( )) && player.getDistance(mc.player) <= this.range)
                    return player;
            }
        } else {
            for (EntityPlayer player : mc.world.playerEntities) {
                if (!player.isDead && !FriendsManager.isFriend(player.getName( )) && player.getDistance(mc.player) <= this.range)
                    return player;
            }
        }
        return null;
    }
}