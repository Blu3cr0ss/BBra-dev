package inc.bbra.exploit.Module.COMBAT;

import inc.bbra.exploit.BBraExploit;
import inc.bbra.exploit.Module.Module;
import inc.bbra.exploit.Module.RENDER.CARender;
import inc.bbra.exploit.utils.*;
import inc.bbra.exploit.utils.other.FriendsManager;
import inc.bbra.exploit.utils.other.Globals;
import inc.bbra.newclickgui.Setting;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class CAura extends Module {
    public CAura(){
        super("CAura", Keyboard.KEY_NONE, Category.COMBAT);

        ArrayList<String> options = new ArrayList();

        options.add("Mainhand");
        options.add("Offhand");

        ArrayList<String> options2 = new ArrayList();

        options2.add("Safe");
        options2.add("Damage");

        ArrayList<String> options3 = new ArrayList();

        options3.add("Queue");
        options3.add("Mix");

        BBraExploit.instance.sManager.rSetting(new Setting("Target Range", this, 15, 8, 50, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Armor Check", this, false));

        BBraExploit.instance.sManager.rSetting(new Setting("Min DMG", this, 8, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Max self DMG", this, 7.5, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("MultiPlace", this, 1, 1, 12, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Delay", this, 2, 0, 20, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Hand", this, options, "Hand"));
        BBraExploit.instance.sManager.rSetting(new Setting("Attack Range", this,  5, 2, 6, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Ign. Terrain", this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Render", this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Rotate",  this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Logic", this, options2, "Logic"));
        BBraExploit.instance.sManager.rSetting(new Setting("Tasks", this, options3, "Tasks"));
    }

    //vars from gui
    private double range = 15;
    private boolean armorCheck = false;

    private double minDmg =  8;
    private double maxSelfD = 7.5;
    private int multiplace = 1;
    private int delay = 2;
    private EnumHand hand = EnumHand.MAIN_HAND;
    private double attackRange = 5;
    private boolean shouldIgnore = true;
    private boolean render = true;
    private boolean rotate = true;
    private String logic = "Safe";
    private boolean doQueue = true;

    //CA mechanism vars
    static Minecraft mc = Minecraft.getMinecraft();
    private EntityPlayer target = null;
    private short ticks = 0;
    private boolean placed = false;

    public static EntityPlayer publicTarget;

    //mechanism

    @SubscribeEvent
    public void onTick(TickEvent.PlayerTickEvent e) throws Exception {
        this.refreshValues();
        this.doCA();
    }

    private void refreshValues(){
        this.range = BBraExploit.instance.sManager.getSettingByName(this.name, "Target Range").getValDouble();
        this.armorCheck = BBraExploit.instance.sManager.getSettingByName(this.name, "Armor Check").getValBoolean();
        this.minDmg = BBraExploit.instance.sManager.getSettingByName(this.name, "Min DMG").getValDouble();
        this.maxSelfD = BBraExploit.instance.sManager.getSettingByName(this.name, "Max self DMG").getValDouble();
        this.multiplace = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "MultiPlace").getValDouble();
        this.delay = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "Delay").getValDouble();
        this.hand = BBraExploit.instance.sManager.getSettingByName(this.name, "Hand").getValString().equals("Mainhand") ? EnumHand.MAIN_HAND:EnumHand.OFF_HAND;
        this.attackRange = BBraExploit.instance.sManager.getSettingByName(this.name, "Attack Range").getValDouble();
        this.shouldIgnore = BBraExploit.instance.sManager.getSettingByName(this.name, "Ign. Terrain").getValBoolean();
        this.render = BBraExploit.instance.sManager.getSettingByName(this.name, "Render").getValBoolean();
        this.rotate = BBraExploit.instance.sManager.getSettingByName(this.name, "Rotate").getValBoolean();
        this.logic = BBraExploit.instance.sManager.getSettingByName(this.name, "Logic").getValString();
        this.doQueue = BBraExploit.instance.sManager.getSettingByName(this.name, "Tasks").getValString().equals("Queue");

        //part2
        try { this.target = publicTarget = this.getTarget();}
        catch (Exception e) { ChatUtil.sendMessage("Failed to get target");}
        this.ticks ++;
        CARender.Do = this.render;
    }

    private void doCA() throws Exception {
        if(this.isAllowedByTicks() && !(this.target == null) && !(mc.player.isDead)) {
            if (this.doQueue){
                if (!this.placed) this.placeCs();
                else this.breakCs();
                this.placed = !this.placed;
            } else {
                this.placeCs();
                this.breakCs();
            }
        }
    }

    private boolean isAllowedByTicks(){
        if (this.delay == 0 || (this.delay > 0 && this.ticks != 0 && this.ticks >= this.delay)){
            this.ticks = 0;
            return true;
        }
        else return false;
    }

    private void placeCs(){
        short crystalsPlaced = 0;
        if(!(this.target == null)){
            List<BlockPos> possibles = this.getBestCrystals(this.multiplace + 1);
            assert possibles != null;
            for(BlockPos pos : possibles){
                if (crystalsPlaced < multiplace &&
                mc.player.getHeldItem(this.hand).getItem().equals(Items.END_CRYSTAL) &&
                CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= this.minDmg &&
                CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore) <= this.maxSelfD &&
                CrystalUtil.calculateDamage(pos, this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(pos, mc.player, this.shouldIgnore) &&
                CrystalUtil.canPlaceCrystal(pos, true, false)){
                    //RenderUtil.drawSolidBlockESP(pos.getX(), pos.getY(), pos.getZ(), 1, 0.5f, 0.7f, 1);
                    if(this.rotate) CrystalUtil.rotateHead(pos.getX(),pos.getY(),pos.getZ(),mc.player);
                    BlockUtil.placeCrystalOnBlock(pos, this.hand, true);
                    crystalsPlaced++;
                }
            }
        }
    }
    private void breakCs() throws Exception {
        ArrayList<EntityEnderCrystal> crystals = this.getCrystals();
        if (!(crystals.isEmpty())) {
            for (EntityEnderCrystal crystal : crystals) {
                if (!(this.target == null) &&
                    CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= this.minDmg &&
                    CrystalUtil.calculateDamage(crystal.getPosition(), mc.player, this.shouldIgnore) <= this.maxSelfD &&
                    CrystalUtil.calculateDamage(crystal.getPosition(), this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(crystals.get(0).getPosition(), mc.player, this.shouldIgnore) &&
                    CrystalUtil.calculateDamage(crystal.getPosition(), mc.player, false) <= mc.player.getHealth() + mc.player.getAbsorptionAmount() &&
                    Minecraft.getMinecraft().player.getCooledAttackStrength(0) == 1) {
                    mc.playerController.updateController();
                    if (this.rotate) EntityUtil.lookAtEntity(crystal);
                    mc.playerController.attackEntity(mc.player, crystal);
                    mc.player.swingArm(this.hand);
                    crystals.clear();
                    return;
                }
            }
        }
    }

    private ArrayList<EntityEnderCrystal> getCrystals(){
        ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>();
        if(!mc.world.loadedEntityList.isEmpty()) {
            for (Entity e : mc.world.loadedEntityList) {
                if (e instanceof EntityEnderCrystal && (e.getDistance(mc.player) <= this.attackRange) && !(e.isDead))
                    crystals.add((EntityEnderCrystal) e);
            }
        }
        return crystals;
    }

    private ArrayList<BlockPos> getBestCrystals(){
        ArrayList<BlockPos> pos2return = new ArrayList<BlockPos>();
        ArrayList<BlockPos> allPoses = new ArrayList<BlockPos>(CrystalUtil.possiblePlacePositions((float) this.attackRange, true, false));
        if(!allPoses.isEmpty() && !(this.target == null)) {
            for (int i = 0; i < allPoses.size(); i++) {
                int bestIndex = 0;
                for (int j = 0; j < allPoses.size(); j++) {
                    float bestCoefficient = 0;
                    float currentCoefficient = 0;
                    if (this.logic == "Damage")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore);
                    else if (this.logic == "Safe")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore) - CrystalUtil.calculateDamage(allPoses.get(j), mc.player, this.shouldIgnore);
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient;
                        bestIndex = j;
                    }
                }
                pos2return.add(allPoses.get(bestIndex));
                allPoses.remove(bestIndex);
                bestIndex = 0;
            }
            return pos2return;
        }
        return null;
    }

    private ArrayList<BlockPos> getBestCrystals(int quantity){
        ArrayList<BlockPos> pos2return = new ArrayList<BlockPos>();
        ArrayList<BlockPos> allPoses = new ArrayList<BlockPos>(CrystalUtil.possiblePlacePositions((float) this.attackRange, true, false));
        if(!allPoses.isEmpty() && !(this.target == null)) {
            for (int i = 0; i < quantity; i++) {
                int bestIndex = 0;
                for (int j = 0; j < allPoses.size(); j++) {
                    float bestCoefficient = 0;
                    float currentCoefficient = 0;
                    if (this.logic == "Damage")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore);
                    else if (this.logic == "Safe")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore) - CrystalUtil.calculateDamage(allPoses.get(j), mc.player, this.shouldIgnore);
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient;
                        bestIndex = j;
                    }
                }
                pos2return.add(allPoses.get(bestIndex));
                allPoses.remove(bestIndex);
                bestIndex = 0;
            }
            return pos2return;
        }
        return null;
    }

    private EntityPlayer getTarget() throws Exception{
        if (this.armorCheck){
            for(EntityPlayer player : mc.world.playerEntities){
                if (player.getTotalArmorValue() > 0 && !player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range && player != mc.player)
                    return player;
            }
        }
        else {
            for(EntityPlayer player : mc.world.playerEntities){
                if (!player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range && player != mc.player)
                    return player;
            }
        }
        return null;
    }
}