package inc.bbra.exploit.Module.COMBAT;

import inc.bbra.exploit.BBraExploit;
import inc.bbra.exploit.Module.Module;
import inc.bbra.exploit.Module.RENDER.CARender;
import inc.bbra.exploit.utils.*;
import inc.bbra.exploit.utils.other.FriendsManager;
import inc.bbra.exploit.utils.other.Globals;
import inc.bbra.newclickgui.Setting;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class CAura extends Module {
    public CAura(){
        super("CAura", Keyboard.KEY_NONE, Category.COMBAT);

        ArrayList<String> options = new ArrayList();

        options.add("Mainhand");
        options.add("Offhand");

        ArrayList<String> options2 = new ArrayList();

        options2.add("Safe");
        options2.add("Damage");

        ArrayList<String> options3 = new ArrayList();

        options3.add("Queue");
        options3.add("Smart");
        options3.add("Mix");

        BBraExploit.instance.sManager.rSetting(new Setting("Target Range", this, 15, 8, 50, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Armor Check", this, false));

        BBraExploit.instance.sManager.rSetting(new Setting("Min DMG", this, 8, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Max self DMG", this, 7.5, 0.1, 20, false));
        BBraExploit.instance.sManager.rSetting(new Setting("MultiPlace", this, 1, 1, 12, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Delay", this, 2, 0, 20, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Hand", this, options, "Hand"));
        BBraExploit.instance.sManager.rSetting(new Setting("Attack Range", this,  5, 2, 6, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Ign. Terrain", this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Render", this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Rotate",  this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Logic", this, options2, "Logic"));
        BBraExploit.instance.sManager.rSetting(new Setting("Tasks", this, options3, "Tasks"));
        BBraExploit.instance.sManager.rSetting(new Setting("Count CPS", this, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Use FacePl", this, false));
        BBraExploit.instance.sManager.rSetting(new Setting("FacePl HP", this, 3, 1, 35, false));
        BBraExploit.instance.sManager.rSetting(new Setting("Face Armor", this, 5, 1, 99, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Face MinDmg", this, 2, 0.1, 10, false));
        BBraExploit.instance.sManager.rSetting(new Setting("FP no armor", this, true));
        BBraExploit.instance.sManager.rSetting(new Setting("Ignore SelfD", this, false));
    }

    //vars from gui
    private double range = 15;
    private boolean armorCheck = false;

    private double minDmg =  8;
    private double maxSelfD = 7.5;
    private int multiplace = 1;
    private int delay = 2;
    private EnumHand hand = EnumHand.MAIN_HAND;
    private double attackRange = 5;
    private boolean shouldIgnore = true;
    private boolean render = true;
    private boolean rotate = true;
    private String logic = "Safe";
    private String queueMode = "Queue";
    private boolean doQueue = true;
    private boolean ignoreSelfD = false;

    //Face Place vars ya
    private boolean FPEnabled = false;
    private float FPHP = 0f;
    private int FPArmor = 0;
    private float FPMinDmg = 0;
    private  boolean doArmorFP = true;

    //CA mechanism vars
    static Minecraft mc = Minecraft.getMinecraft();
    private EntityPlayer target = null;
    private short ticks = 0;
    private boolean placed = false;
    private boolean refreshed = false;
    private boolean doCount = true;
    private int ticksWorked = 0;
    private int crystalsPlacedAtAll = 0;

    public static EntityPlayer publicTarget;

    //mechanism

    @SubscribeEvent
    public void onTick(TickEvent.PlayerTickEvent e) throws Exception {
        this.doRefresh();
        this.doCA();
    }

    private void refreshValues(){
        this.range = BBraExploit.instance.sManager.getSettingByName(this.name, "Target Range").getValDouble();
        this.armorCheck = BBraExploit.instance.sManager.getSettingByName(this.name, "Armor Check").getValBoolean();
        this.minDmg = BBraExploit.instance.sManager.getSettingByName(this.name, "Min DMG").getValDouble();
        this.maxSelfD = BBraExploit.instance.sManager.getSettingByName(this.name, "Max self DMG").getValDouble();
        this.multiplace = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "MultiPlace").getValDouble();
        this.delay = (int)BBraExploit.instance.sManager.getSettingByName(this.name, "Delay").getValDouble();
        this.hand = BBraExploit.instance.sManager.getSettingByName(this.name, "Hand").getValString().equals("Mainhand") ? EnumHand.MAIN_HAND:EnumHand.OFF_HAND;
        this.attackRange = BBraExploit.instance.sManager.getSettingByName(this.name, "Attack Range").getValDouble();
        this.shouldIgnore = BBraExploit.instance.sManager.getSettingByName(this.name, "Ign. Terrain").getValBoolean();
        this.render = BBraExploit.instance.sManager.getSettingByName(this.name, "Render").getValBoolean();
        this.rotate = BBraExploit.instance.sManager.getSettingByName(this.name, "Rotate").getValBoolean();
        this.logic = BBraExploit.instance.sManager.getSettingByName(this.name, "Logic").getValString();
        this.queueMode = BBraExploit.instance.sManager.getSettingByName(this.name, "Tasks").getValString();
        this.doCount = BBraExploit.instance.sManager.getSettingByName(this.name, "Count CPS").getValBoolean();
        this.FPEnabled = BBraExploit.instance.sManager.getSettingByName(this.name, "Use FacePl").getValBoolean();
        this.FPHP = (float) BBraExploit.instance.sManager.getSettingByName(this.name, "FacePl HP").getValDouble();
        this.FPArmor = (int) BBraExploit.instance.sManager.getSettingByName(this.name, "Face Armor").getValDouble();
        this.FPMinDmg = (float) BBraExploit.instance.sManager.getSettingByName(this.name, "Face MinDmg").getValDouble();
        this.doArmorFP = BBraExploit.instance.sManager.getSettingByName(this.name, "FP no armor").getValBoolean();
        this.ignoreSelfD = BBraExploit.instance.sManager.getSettingByName(this.name, "Ignore SelfD").getValBoolean();

        //part2
        try { this.target = publicTarget = this.getTarget();}
        catch (Exception e) { ChatUtil.sendMessage("Failed to get target");}
        this.ticks ++;
        CARender.Do = this.render && this.toggled;
        CARender.printCPS = this.doCount && this.toggled;
        CARender.CPS = this.getCPS();
        this.doQueue = this.queueMode.equals("Queue") || this.queueMode.equals("Smart");
        if (this.isEzTarget(this.target)){
            this.minDmg = this.FPMinDmg;
            this.maxSelfD = 36f;
        }
    }

    private void doCA() throws Exception {
        if(this.isAllowedByTicks() && !(this.target == null) && !(mc.player.isDead)) {
            this.ticksWorked++;
            if (this.doQueue){
                if (!this.placed) this.placeCs();
                else this.breakCs();
                this.placed = !this.placed;
            } else {
                this.placeCs();
                this.breakCs();
            }
        }
    }
    private void doRefresh(){
        if (!this.refreshed) this.refreshValues();
        this.refreshed = !this.refreshed;
    }

    private float getCPS(){
        if (this.doCount) {
            if (this.crystalsPlacedAtAll > 0) { return (this.ticksWorked * 20) / this.crystalsPlacedAtAll; }
            if (ticksWorked > 100) { this.ticksWorked = this.crystalsPlacedAtAll = 0; }
        }
        return 0;
    }

    private boolean isAllowedByTicks(){
        if (this.queueMode.equals("Queue") || this.queueMode.equals("Mix")){
            if (this.delay == 0 || (this.delay > 0 && this.ticks != 0 && this.ticks >= this.delay)){
                this.ticks = 0;
                return true;
            }
            else return false;
        }
        else if (this.queueMode.equals("Smart")){
            if (this.delay == 0){ this.ticks = 0; return true; }
            int newDelay = this.delay / 2;
            if (newDelay == 0) newDelay = 1;
            if (this.ticks != 0 && this.ticks >= newDelay) {this.ticks = 0; return true;}
        }
        return false;
    }

    private boolean isEzTarget(EntityPlayer target){
        if (this.FPEnabled && target != null) {
            if (target.getHealth() + target.getAbsorptionAmount() < this.FPHP) return true;
            if (CrystalUtil.getArmourFucker(target, this.FPHP)) return true;
            if (target.getTotalArmorValue() < 10) return true;
        }
        return false;
    }

    private void placeCs(){
        short crystalsPlaced = 0;
        if(!(this.target == null)){
            List<BlockPos> possibles = this.getBestCrystals(this.multiplace + 1);
            if (possibles == null|| possibles.isEmpty()) return;
            for (int i = 0; i < possibles.size(); i++){
                BlockPos pos = possibles.get(i);
                if (crystalsPlaced < multiplace &&
                mc.player.getHeldItem(this.hand).getItem().equals(Items.END_CRYSTAL) && this.isGoodBlock(pos)){
                    //RenderUtil.drawSolidBlockESP(pos.getX(), pos.getY(), pos.getZ(), 1, 0.5f, 0.7f, 1);
                    if(this.rotate) CrystalUtil.rotateHead(pos.getX(),pos.getY(),pos.getZ(),mc.player);
                    BlockUtil.placeCrystalOnBlock(pos, this.hand, true);
                    crystalsPlaced++;
                    this.crystalsPlacedAtAll++;
                }
            }
        }
    }
    private void breakCs() throws Exception {
        ArrayList<EntityEnderCrystal> crystals = this.getCrystals();
        if (!(crystals.isEmpty())) {
            for (EntityEnderCrystal crystal : crystals) {
                if (this.isGoodCrystal(crystal)) {
                    mc.playerController.updateController();
                    if (this.rotate) EntityUtil.lookAtEntity(crystal);
                    mc.playerController.attackEntity(mc.player, crystal);
                    mc.player.swingArm(this.hand);
                    crystals.clear();
                    return;
                }
            }
        }
    }

    private ArrayList<EntityEnderCrystal> getCrystals(){
        ArrayList<EntityEnderCrystal> crystals = new ArrayList<EntityEnderCrystal>();
        if(!mc.world.loadedEntityList.isEmpty()) {
            //for (Entity e : mc.world.loadedEntityList) {
            for(int i = 0; i < mc.world.loadedEntityList.size(); i++){
                Entity e = mc.world.loadedEntityList.get(i);
                if (e instanceof EntityEnderCrystal && (e.getDistance(mc.player) <= this.attackRange) && !(e.isDead))
                    crystals.add((EntityEnderCrystal) e);
            }
        }
        return crystals;
    }

    private ArrayList<BlockPos> getBestCrystals(){
        ArrayList<BlockPos> pos2return = new ArrayList<BlockPos>();
        ArrayList<BlockPos> allPoses = new ArrayList<BlockPos>(CrystalUtil.possiblePlacePositions((float) this.attackRange, true, false));
        if(!allPoses.isEmpty() && !(this.target == null)) {
            for (int i = 0; i < allPoses.size(); i++) {
                int bestIndex = 0;
                for (int j = 0; j < allPoses.size(); j++) {
                    float bestCoefficient = 0;
                    float currentCoefficient = 0;
                    if (this.logic == "Damage")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore);
                    else if (this.logic == "Safe")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore) - CrystalUtil.calculateDamage(allPoses.get(j), mc.player, this.shouldIgnore);
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient;
                        bestIndex = j;
                    }
                }
                pos2return.add(allPoses.get(bestIndex));
                allPoses.remove(bestIndex);
                bestIndex = 0;
            }
            return pos2return;
        }
        return null;
    }

    private boolean isGoodCrystal(EntityEnderCrystal targetCrystal){
        if (this.isEzTarget(this.target)) return (CrystalUtil.calculateDamage(targetCrystal.getPosition(), this.target,shouldIgnore) >= this.FPMinDmg && mc.player.getCooledAttackStrength(0) == 1);
        if (this.ignoreSelfD) return (CrystalUtil.calculateDamage(targetCrystal.getPosition(), this.target, this.shouldIgnore) >= this.minDmg && mc.player.getCooledAttackStrength(0) == 1);
        return (!(this.target == null) &&
                CrystalUtil.calculateDamage(targetCrystal.getPosition(), this.target, this.shouldIgnore) >= this.minDmg &&
                CrystalUtil.calculateDamage(targetCrystal.getPosition(), mc.player, this.shouldIgnore) <= this.maxSelfD &&
                CrystalUtil.calculateDamage(targetCrystal.getPosition(), this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(targetCrystal.getPosition(), mc.player, this.shouldIgnore) &&
                CrystalUtil.calculateDamage(targetCrystal.getPosition(), mc.player, false) <= mc.player.getHealth() + mc.player.getAbsorptionAmount() &&
                Minecraft.getMinecraft().player.getCooledAttackStrength(0) == 1);
    }

    private boolean isGoodBlock(BlockPos targetBlock){
        if (this.isEzTarget(this.target)) return (CrystalUtil.calculateDamage(targetBlock, this.target, this.shouldIgnore) >= this.FPMinDmg && CrystalUtil.canPlaceCrystal(targetBlock, true, false));
        if (this.ignoreSelfD) return (CrystalUtil.calculateDamage(targetBlock, this.target, this.shouldIgnore) >= this.minDmg && CrystalUtil.canPlaceCrystal(targetBlock, true, false));
        return (CrystalUtil.calculateDamage(targetBlock, this.target, this.shouldIgnore) >= this.minDmg &&
                CrystalUtil.calculateDamage(targetBlock, mc.player, this.shouldIgnore) <= this.maxSelfD &&
                CrystalUtil.calculateDamage(targetBlock, this.target, this.shouldIgnore) >= CrystalUtil.calculateDamage(targetBlock, mc.player, this.shouldIgnore) &&
                CrystalUtil.canPlaceCrystal(targetBlock, true, false));
    }

    private ArrayList<BlockPos> getBestCrystals(int quantity){
        ArrayList<BlockPos> pos2return = new ArrayList<BlockPos>();
        ArrayList<BlockPos> allPoses = new ArrayList<BlockPos>(CrystalUtil.possiblePlacePositions((float) this.attackRange, true, false));
        if(!allPoses.isEmpty() && !(this.target == null) && allPoses.size() >= quantity) {
            for (int i = 0; i < quantity; i++) {
                int bestIndex = 0;
                for (int j = 0; j < allPoses.size(); j++) {
                    float bestCoefficient = 0;
                    float currentCoefficient = 0;
                    if (this.logic == "Damage")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore);
                    else if (this.logic == "Safe")
                        currentCoefficient = CrystalUtil.calculateDamage(allPoses.get(j), this.target, this.shouldIgnore) - CrystalUtil.calculateDamage(allPoses.get(j), mc.player, this.shouldIgnore);
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient;
                        bestIndex = j;
                    }
                }
                pos2return.add(allPoses.get(bestIndex));
                allPoses.remove(bestIndex);
                bestIndex = 0;
            }
            return pos2return;
        }
        return null;
    }

    private EntityPlayer getTarget() throws Exception{
        if (this.armorCheck){
            for(EntityPlayer player : mc.world.playerEntities){
                if (player.getTotalArmorValue() > 0 && !player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range && player != mc.player)
                    return player;
            }
        }
        else {
            for(EntityPlayer player : mc.world.playerEntities){
                if (!player.isDead && !FriendsManager.isFriend(player.getName()) && player.getDistance(mc.player) <= this.range && player != mc.player)
                    return player;
            }
        }
        return null;
    }

    private int findCrystalsHotbar() {
        for (int i = 0; i < 9; i++) {
            if (mc.player.inventory.getStackInSlot(i).getItem() == Items.END_CRYSTAL) {
                return i;
            }
        }
        return -1;
    }
}