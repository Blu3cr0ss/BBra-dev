package inc.bbra.exploit.Module.COMBAT

import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.Module.RENDER.CARender
import inc.bbra.exploit.clickgui.modules.settings.BoolSetting
import inc.bbra.exploit.clickgui.modules.settings.FloatSetting
import inc.bbra.exploit.clickgui.modules.settings.IntSetting
import inc.bbra.exploit.clickgui.modules.settings.ModeSetting
import inc.bbra.exploit.clickgui.modules.settings.PageSetting
import inc.bbra.exploit.utils.BlockUtil
import inc.bbra.exploit.utils.ChatUtil
import inc.bbra.exploit.utils.CrystalUtil
import inc.bbra.exploit.utils.EntityUtil
import inc.bbra.exploit.utils.other.FriendsManager
import inc.bbra.exploit.utils.other.MathsUtil
import inc.bbra.exploit.utils.other.array
import net.minecraft.client.Minecraft
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard

class CAura : Module("KotlinCAura", Keyboard.KEY_NONE, Category.COMBAT) {

    private var doQueue = true
    private var target: EntityPlayer? = null
    private var ticks: Short = 0
    private var placed = false
    private var refreshed = false
    private var doCount = true
    private var ticksWorked = 0
    private var crystalsPlacedAtAll = 0
    private var crystals = ArrayList<EntityEnderCrystal>()
    var minDmg = 0.0
    var maxSelfD = 0.0

    //gui section
    var hand:EnumHand = EnumHand.MAIN_HAND
    //General
    var generalPage: PageSetting? = PageSetting(this, "General")
    var multiplace:IntSetting = IntSetting(this, "Multiplace", generalPage, 1, 1, 10)
    var delay: IntSetting = IntSetting(this, "Delay(Ticks)", generalPage, 2, 0, 1)
    var shouldIgnore: BoolSetting = BoolSetting(this, "IgnoreTerrain", generalPage, false)
    var Hand: ModeSetting = ModeSetting(this, "Hand", generalPage, array.Companion.of("Mainhand", "Offhand"))
    var logic: ModeSetting = ModeSetting(this, "CalculationLogic", generalPage, array.Companion.of("Safe", "Damage"))
    var queueMode: ModeSetting = ModeSetting(this, "TasksMode", generalPage, array.Companion.of("Queue", "Smart", "Mix"))
    var ignoreSelfD: BoolSetting = BoolSetting(this, "IgnoreSelfDMG", generalPage, false)
    var avoidSuicide: BoolSetting = BoolSetting(this, "AvoidSuicide", generalPage, true)
    var render: BoolSetting = BoolSetting(this, "RenderStuff", generalPage, true)
    var rotate: BoolSetting = BoolSetting(this, "Rotations", generalPage, true)
    //Target
    var targetPage: PageSetting? = PageSetting(this, "Targeting")
    var range:FloatSetting = FloatSetting(this, "Range",targetPage,15f, 3f, 50f)
    var armorCheck:BoolSetting = BoolSetting(this, "ArmorCheck",targetPage, true)
    var attackRange:FloatSetting = FloatSetting(this, "AttackRange", targetPage, 5f, 2f, 6f)
    var wallRange:FloatSetting = FloatSetting(this, "WallRange", targetPage, 3f, 1f, 6f)
    //Damage
    var dmgPage: PageSetting? = PageSetting(this, "Damages")
    var MinDmg: FloatSetting = FloatSetting(this, "MinDMG", dmgPage, 8f, .1f, 20f)
    var MaxSelfD: FloatSetting = FloatSetting(this, "MaxSelfDMG", dmgPage, 7.5f, .1f, 20f)
    //FacePlace
    var FPPage: PageSetting? = PageSetting(this, "FacePlace")
    var FPEnabled: BoolSetting = BoolSetting(this, "UseFacePlace", FPPage, true)
    var FPHP: FloatSetting = FloatSetting(this, "EnemyHP", FPPage, 3f, 0.1f, 36f)
    var FPArmor: FloatSetting = FloatSetting(this, "EnemyArmor%", FPPage, 1f, .1f, 99f)
    var FPMinDmg: FloatSetting = FloatSetting(this, "FaceMinDMG", FPPage, 2f, .1f, 10f)
    var doArmorFP: BoolSetting = BoolSetting(this, "NoFullArmorFP", FPPage, true)

    //mechanism
    @SubscribeEvent
    @Throws(Exception::class)
    fun onTick(e: PlayerTickEvent?) {
        doRefresh()
        try {
            doCA()
        } catch (ex: Exception) {
            ChatUtil.sendMessage("Failed to perform!")
        }
    }

    private fun refreshValues() {
        minDmg = MinDmg.`val`.toDouble()
        maxSelfD = MaxSelfD.`val`.toDouble()
        //part2
        try {
            publicTarget = getTarget()
            target = publicTarget
        } catch (e: Exception) {
            ChatUtil.sendMessage("Failed to get target")
        }
        ticks++
        CARender.Do = render.`val`
        doQueue = queueMode.`val` == "Queue" || queueMode.`val` == "Smart"
        if (isEzTarget(target)) {
            minDmg = FPMinDmg.`val`.toDouble()
            maxSelfD = 36.0
        }
    }

    @Throws(Exception::class)
    private fun doCA() {
        if (isAllowedByTicks && target != null && !Companion.mc.player.isDead) {
            if (doQueue) {
                if (!placed) placeCs() else breakCs()
                placed = !placed
            } else {
                placeCs()
                breakCs()
            }
        }
    }

    private fun doRefresh() {
        if (!refreshed) refreshValues()
        refreshed = !refreshed
        if (Hand.`val` == "Mainhand") hand = EnumHand.MAIN_HAND
        else if (Hand.`val` == "Offhand") hand = EnumHand.OFF_HAND
        crystals = getCrystals()
    }

    private val cPS: Float
        private get() {
            if (doCount) {
                if (crystalsPlacedAtAll > 0) {
                    return (ticksWorked * 20 / crystalsPlacedAtAll).toFloat()
                }
                if (ticksWorked > 200) {
                    crystalsPlacedAtAll = 0
                    ticksWorked = crystalsPlacedAtAll
                }
            }
            return 0f;
        }
    private val isAllowedByTicks: Boolean
        private get() {
            ticksWorked++
            if (target != null && isEzTarget(target)) return true
            if (queueMode.`val` === "Queue" || queueMode.`val` === "Mix") {
                return if ((delay.`val` == 0 || delay.`val` > 0 && ticks.toInt() != 0 && ticks >= delay.`val`)) {
                    ticks = 0
                    true
                } else false
            } else if (queueMode.`val` == "Smart") {
                if (delay.`val` == 0) {
                    ticks = 0
                    return true
                }
                var newDelay = delay.`val` / 2
                if (newDelay == 0) newDelay = 1
                if (ticks.toInt() != 0 && ticks >= newDelay) {
                    ticks = 0
                    return true
                }
            }
            return false
        }

    private fun isEzTarget(target: EntityPlayer?): Boolean {
        if (FPEnabled.`val` && target != null) {
            if (target.health + target.absorptionAmount < FPHP.`val`) return true
            if (CrystalUtil.getArmourFucker(target, FPHP.`val`)) return true
            if (target.totalArmorValue < 10) return true
        }
        return false
    }

    private fun placeCs() {
        var crystalsPlaced: Short = 0
        if (target != null) {
            val possibles: List<BlockPos>? = getBestBlocks(multiplace.`val` + 1)
            if (possibles == null || possibles.isEmpty()) return
            for (i in possibles.indices) {
                val pos = possibles[i]
                if (crystalsPlaced < multiplace.`val` && Companion.mc.player.getHeldItem(
                        hand
                    ).item == Items.END_CRYSTAL && CrystalUtil.canPlaceCrystal(pos, true, false)
                ) {
                    //RenderUtil.drawSolidBlockESP(pos.getX(), pos.getY(), pos.getZ(), 1, 0.5f, 0.7f, 1);
                    if (rotate.`val`) CrystalUtil.rotateHead(
                        pos.x.toDouble(),
                        pos.y.toDouble(),
                        pos.z.toDouble(),
                        Companion.mc.player
                    )
                    BlockUtil.placeCrystalOnBlock(pos, hand, true)
                    //ChatUtil.sendMessage("Tried to place");
                    crystalsPlaced++
                    crystalsPlacedAtAll++
                }
            }
        }
    }

    @Throws(Exception::class)
    private fun breakCs() {
        val crystals = getBestCrystals(multiplace.`val`) ?: return
        //for (EntityEnderCrystal crystal : crystals) {
        for (i in crystals.indices) {
            val crystal = crystals[i]
            Companion.mc.playerController.updateController()
            if (rotate.`val`) EntityUtil.lookAtEntity(crystal)
            Companion.mc.playerController.attackEntity(Companion.mc.player, crystal)
            Companion.mc.player.swingArm(hand)
            //ChatUtil.sendMessage("Tried to break");
            crystals.clear()
            return
        }
    }

    private fun getCrystals(): ArrayList<EntityEnderCrystal> {
        val crystals = ArrayList<EntityEnderCrystal>()
        if (!Companion.mc.world.loadedEntityList.isEmpty()) {
            //for (Entity e : mc.world.loadedEntityList) {
            for (i in Companion.mc.world.loadedEntityList.indices) {
                val e = Companion.mc.world.loadedEntityList[i]
                if (e is EntityEnderCrystal && (e.getDistance(Companion.mc.player) <= attackRange.`val`) && !e.isDead) crystals.add(
                    e as EntityEnderCrystal
                )
            }
        }
        return crystals
    }

    private fun isGoodCrystal(targetCrystal: EntityEnderCrystal): Boolean {
        if (isEzTarget(target)) return CrystalUtil.calculateDamage(targetCrystal.position, target, shouldIgnore.`val`) >= FPMinDmg.`val` && Companion.mc.player.getCooledAttackStrength(0f) == 1f
        return if (ignoreSelfD.`val`) CrystalUtil.calculateDamage(targetCrystal.position, target, shouldIgnore.`val`) >= minDmg &&
                Companion.mc.player.getCooledAttackStrength(0f) == 1f else target != null &&
                CrystalUtil.calculateDamage(targetCrystal.position, target, shouldIgnore.`val`) >= this.minDmg &&
                CrystalUtil.calculateDamage(targetCrystal.position, Companion.mc.player, this.shouldIgnore.`val`) <= this.maxSelfD &&
                CrystalUtil.calculateDamage(targetCrystal.position, this.target, shouldIgnore.`val`) >= CrystalUtil.calculateDamage(targetCrystal.position, Companion.mc.player, shouldIgnore.`val`) &&
                CrystalUtil.calculateDamage(targetCrystal.position, Companion.mc.player, false) <= Companion.mc.player.health + Companion.mc.player.absorptionAmount &&
                Minecraft.getMinecraft().player.getCooledAttackStrength(0f) == 1f
    }

    private fun GoodnessOfCrystal(crystal: EntityEnderCrystal, target: EntityPlayer): Double {
        if (Companion.mc.player.canEntityBeSeen(crystal)) {
            if (Companion.mc.player.getDistanceSq(crystal) > MathsUtil.square(attackRange.`val`)) return 0.0
        } else if (Companion.mc.player.getDistanceSq(crystal) > MathsUtil.square(wallRange.`val`)) return 0.0

        if (crystal.isDead) return 0.0
        val targetDamage = CrystalUtil.calculateDamage(crystal, target, shouldIgnore.`val`).toDouble()
        if (isEzTarget(this.target) && targetDamage >= FPMinDmg.`val`) return targetDamage
        if (targetDamage < minDmg && EntityUtil.getHealth(target) - targetDamage > 0) return 0.0
        var selfDamage = 0.0
        if (!ignoreSelfD.`val` && !isEzTarget(this.target)) {
            selfDamage = CrystalUtil.calculateDamage(crystal, Companion.mc.player, shouldIgnore.`val`).toDouble()
            if (targetDamage < this.minDmg || selfDamage > maxSelfD || targetDamage < selfDamage) return 0.0
        }
        if (selfDamage > maxSelfD) return 0.0
        if (EntityUtil.getHealth(Companion.mc.player) - selfDamage <= 0 && avoidSuicide.`val`) return 0.0
        when (logic.`val`) {
            "Safe" -> return targetDamage - selfDamage
            "Damage" -> return targetDamage
        }
        return 0.0
    }

    private fun GoodnessOfBlock(blockPos: BlockPos, target: EntityPlayer): Double {
        if (!CrystalUtil.canSeePos(blockPos)) {
            if (Companion.mc.player.getDistanceSq(blockPos) > MathsUtil.square(wallRange.`val`)) return 0.0
        }
        else if (Companion.mc.player.getDistanceSq(blockPos) > MathsUtil.square(attackRange.`val`)) return 0.0
        val targetDamage = CrystalUtil.calculateDamage(blockPos, target, shouldIgnore.`val`).toDouble()
        if (isEzTarget(this.target) && targetDamage >= FPMinDmg.`val`) return targetDamage
        if (targetDamage < minDmg && EntityUtil.getHealth(target) - targetDamage > 0) return 0.0
        var selfDamage = 0.0
        if (!ignoreSelfD.`val` && !isEzTarget(this.target)) {
            selfDamage = CrystalUtil.calculateDamage(blockPos, Companion.mc.player, shouldIgnore.`val`).toDouble()
            if (targetDamage < this.minDmg || selfDamage > maxSelfD || targetDamage < selfDamage) return 0.0
        }
        if (selfDamage > maxSelfD) return 0.0
        if (EntityUtil.getHealth(Companion.mc.player) - selfDamage <= 0 && avoidSuicide.`val`) return 0.0
        when (logic.`val`) {
            "Safe" -> return targetDamage - selfDamage
            "Damage" -> return targetDamage
        }
        return 0.0
    }

    private fun getBestBlocks(quantity: Int): ArrayList<BlockPos>? {
        val pos2return = ArrayList<BlockPos>()
        val allPoses = ArrayList(CrystalUtil.possiblePlacePositions(attackRange.`val`, true, false))
        if (!allPoses.isEmpty() && target != null && allPoses.size >= quantity) {
            for (i in 0 until quantity) {
                var bestIndex = 0
                var bestCoefficient = 0.0
                for (j in allPoses.indices) {
                    val currentCoefficient = GoodnessOfBlock(allPoses[j], target!!)
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient
                        bestIndex = j
                    }
                }
                pos2return.add(allPoses[bestIndex])
                allPoses.removeAt(bestIndex)
                bestIndex = 0
            }
            return pos2return
        }
        return null
    }

    private fun getBestCrystals(quantity: Int): ArrayList<EntityEnderCrystal?>? {
        val crystals2return: ArrayList<EntityEnderCrystal?> = ArrayList()
        val allCrystals = ArrayList(crystals)
        if (!allCrystals.isEmpty() && target != null && allCrystals.size >= quantity) {
            for (i in 0 until quantity) {
                var bestIndex = 0
                var bestCoefficient = 0.0
                for (l in allCrystals.indices) {
                    val currentCoefficient = GoodnessOfCrystal(allCrystals[l], target!!)
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient
                        bestIndex = l
                    }
                }
                try {
                    crystals2return.add(allCrystals[bestIndex])
                    allCrystals.removeAt(bestIndex)
                } catch (ex: Exception) {
                    ChatUtil.sendMessage("Shit! Array problem")
                }
                bestIndex = 0
            }
            return crystals2return
        }
        return null
    }

    @Throws(Exception::class)
    private fun getTarget(): EntityPlayer? {
        val targets: ArrayList<EntityPlayer?> = ArrayList()
        if (armorCheck.`val`) {
            for (player in mc.world.playerEntities) {
                if (player.totalArmorValue > 0 && !player.isDead && !FriendsManager.isFriend(player.name) && player.getDistance(Companion.mc.player) <= range.`val` &&
                    player !== Companion.mc.player) targets.add(player)
            }
        } else {
            for (player in Companion.mc.world.playerEntities) {
                if (!player.isDead && !FriendsManager.isFriend(player.name) && player.getDistance(Companion.mc.player) <= range.`val` && player !== Companion.mc.player) targets.add(
                    player
                )
            }
        }
        var closestPlayer: EntityPlayer? = null
        for (i in targets.indices) {
            if (i == 0) closestPlayer = targets[0] else {
                if (targets[i]!!.getDistance(Companion.mc.player) < closestPlayer!!.getDistance(Companion.mc.player)) closestPlayer =
                    targets[i]
            }
        }
        return closestPlayer
    }

    private fun findCrystalsHotbar(): Int {
        for (i in 0..8) {
            if (Companion.mc.player.inventory.getStackInSlot(i).item === Items.END_CRYSTAL) {
                return i
            }
        }
        return -1
    }

    companion object {
        //CA mechanism vars
        @JvmStatic
        var pubTarget: EntityPlayer? = null;
        var mc = Minecraft.getMinecraft()
        var publicTarget: EntityPlayer? = null
    }
}