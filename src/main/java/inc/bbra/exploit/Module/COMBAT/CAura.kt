package inc.bbra.exploit.Module.COMBAT

import inc.bbra.exploit.BBraExploit
import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.Module.RENDER.CARender
import inc.bbra.exploit.utils.BlockUtil
import inc.bbra.exploit.utils.ChatUtil
import inc.bbra.exploit.utils.CrystalUtil
import inc.bbra.exploit.utils.EntityUtil
import inc.bbra.exploit.utils.other.FriendsManager
import inc.bbra.exploit.utils.other.MathsUtil
import inc.bbra.newclickgui.Setting
import net.minecraft.client.Minecraft
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard

class CAura : Module("CAura", Keyboard.KEY_NONE, Category.COMBAT) {
    //vars from gui
    private var range = 15.0
    private var armorCheck = false
    private var minDmg = 8.0
    private var maxSelfD = 7.5
    private var multiplace = 1
    private var delay = 2
    private var hand = EnumHand.MAIN_HAND
    private var attackRange = 5.0
    private var wallRange = 3.0
    private var shouldIgnore = true
    private var render = true
    private var rotate = true
    private var logic = "Safe"
    private var queueMode = "Queue"
    private var doQueue = true
    private var ignoreSelfD = false
    private var avoidSuicide = true

    //Face Place vars yo
    private var FPEnabled = false
    private var FPHP = 0f
    private var FPArmor = 0
    private var FPMinDmg = 0f
    private var doArmorFP = true
    private var target: EntityPlayer? = null
    private var ticks: Short = 0
    private var placed = false
    private var refreshed = false
    private var doCount = true
    private var ticksWorked = 0
    private var crystalsPlacedAtAll = 0
    private var crystals = ArrayList<EntityEnderCrystal>()

    init {
        val options: ArrayList<String?> = ArrayList()
        options.add("Mainhand")
        options.add("Offhand")
        val options2: ArrayList<String?> = ArrayList()
        options2.add("Safe")
        options2.add("Damage")
        val options3: ArrayList<String?> = ArrayList()
        options3.add("Queue")
        options3.add("Smart")
        options3.add("Mix")
        BBraExploit.instance.sManager.rSetting(Setting("Target Range", this, 15.0, 8.0, 50.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("Armor Check", this, false))
        BBraExploit.instance.sManager.rSetting(Setting("Min DMG", this, 8.0, 0.1, 20.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("Max self DMG", this, 7.5, 0.1, 20.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("MultiPlace", this, 1.0, 1.0, 12.0, true))
        BBraExploit.instance.sManager.rSetting(Setting("Delay", this, 2.0, 0.0, 20.0, true))
        BBraExploit.instance.sManager.rSetting(Setting("Hand", this, options, "Hand"))
        BBraExploit.instance.sManager.rSetting(Setting("Attack Range", this, 5.0, 2.0, 6.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("Walls Range", this, 3.0, 0.0, 6.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("Ign. Terrain", this, true))
        BBraExploit.instance.sManager.rSetting(Setting("Render", this, true))
        BBraExploit.instance.sManager.rSetting(Setting("Rotate", this, true))
        BBraExploit.instance.sManager.rSetting(Setting("Logic", this, options2, "Logic"))
        BBraExploit.instance.sManager.rSetting(Setting("Tasks", this, options3, "Tasks"))
        BBraExploit.instance.sManager.rSetting(Setting("Count CPS", this, false))
        BBraExploit.instance.sManager.rSetting(Setting("Use FacePl", this, false))
        BBraExploit.instance.sManager.rSetting(Setting("FacePl HP", this, 3.0, 1.0, 35.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("Face Armor", this, 5.0, 1.0, 99.0, true))
        BBraExploit.instance.sManager.rSetting(Setting("Face MinDmg", this, 2.0, 0.1, 10.0, false))
        BBraExploit.instance.sManager.rSetting(Setting("FP no armor", this, true))
        BBraExploit.instance.sManager.rSetting(Setting("Ignore SelfD", this, false))
        BBraExploit.instance.sManager.rSetting(Setting("No Suicide", this, true))
    }

    //mechanism
    @SubscribeEvent
    @Throws(Exception::class)
    fun onTick(e: PlayerTickEvent?) {
        doRefresh()
        try {
            doCA()
        } catch (ex: Exception) {
            ChatUtil.sendMessage("Failed to perform!")
        }
    }

    private fun refreshValues() {
        range = BBraExploit.instance.sManager.getSettingByName(name, "Target Range").valDouble
        armorCheck = BBraExploit.instance.sManager.getSettingByName(name, "Armor Check").valBoolean
        minDmg = BBraExploit.instance.sManager.getSettingByName(name, "Min DMG").valDouble
        maxSelfD = BBraExploit.instance.sManager.getSettingByName(name, "Max self DMG").valDouble
        multiplace = BBraExploit.instance.sManager.getSettingByName(name, "MultiPlace").valDouble.toInt()
        delay = BBraExploit.instance.sManager.getSettingByName(name, "Delay").valDouble.toInt()
        hand = if (BBraExploit.instance.sManager.getSettingByName(name, "Hand").valString == "Mainhand") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
        attackRange = BBraExploit.instance.sManager.getSettingByName(name, "Attack Range").valDouble
        wallRange = BBraExploit.instance.sManager.getSettingByName(name, "Walls Range").valDouble
        shouldIgnore = BBraExploit.instance.sManager.getSettingByName(name, "Ign. Terrain").valBoolean
        render = BBraExploit.instance.sManager.getSettingByName(name, "Render").valBoolean
        rotate = BBraExploit.instance.sManager.getSettingByName(name, "Rotate").valBoolean
        logic = BBraExploit.instance.sManager.getSettingByName(name, "Logic").valString
        queueMode = BBraExploit.instance.sManager.getSettingByName(name, "Tasks").valString
        doCount = BBraExploit.instance.sManager.getSettingByName(name, "Count CPS").valBoolean
        FPEnabled = BBraExploit.instance.sManager.getSettingByName(name, "Use FacePl").valBoolean
        FPHP = BBraExploit.instance.sManager.getSettingByName(name, "FacePl HP").valDouble.toFloat()
        FPArmor = BBraExploit.instance.sManager.getSettingByName(name, "Face Armor").valDouble.toInt()
        FPMinDmg = BBraExploit.instance.sManager.getSettingByName(name, "Face MinDmg").valDouble.toFloat()
        doArmorFP = BBraExploit.instance.sManager.getSettingByName(name, "FP no armor").valBoolean
        ignoreSelfD = BBraExploit.instance.sManager.getSettingByName(name, "Ignore SelfD").valBoolean
        avoidSuicide = BBraExploit.instance.sManager.getSettingByName(name, "No Suicide").valBoolean

        //part2
        try {
            publicTarget = getTarget()
            target = publicTarget
        } catch (e: Exception) {
            ChatUtil.sendMessage("Failed to get target")
        }
        ticks++
        CARender.Do = render && toggled
        CARender.printCPS = doCount && toggled
        CARender.CPS = cPS
        doQueue = queueMode == "Queue" || queueMode == "Smart"
        if (isEzTarget(target)) {
            minDmg = FPMinDmg.toDouble()
            maxSelfD = 36.0
        }
    }

    @Throws(Exception::class)
    private fun doCA() {
        if (isAllowedByTicks && target != null && !Companion.mc.player.isDead) {
            if (doQueue) {
                if (!placed) placeCs() else breakCs()
                placed = !placed
            } else {
                placeCs()
                breakCs()
            }
        }
    }

    private fun doRefresh() {
        if (!refreshed) refreshValues()
        refreshed = !refreshed
        crystals = getCrystals()
    }

    private val cPS: Float
        private get() {
            if (doCount) {
                if (crystalsPlacedAtAll > 0) {
                    return (ticksWorked * 20 / crystalsPlacedAtAll).toFloat()
                }
                if (ticksWorked > 200) {
                    crystalsPlacedAtAll = 0
                    ticksWorked = crystalsPlacedAtAll
                }
            }
            return 0f;
        }
    private val isAllowedByTicks: Boolean
        private get() {
            ticksWorked++
            if (target != null && isEzTarget(target)) return true
            if (queueMode === "Queue" || queueMode === "Mix") {
                return if ((delay == 0 || delay > 0 && ticks.toInt() != 0 && ticks >= delay)) {
                    ticks = 0
                    true
                } else false
            } else if (queueMode == "Smart") {
                if (delay == 0) {
                    ticks = 0
                    return true
                }
                var newDelay = delay / 2
                if (newDelay == 0) newDelay = 1
                if (ticks.toInt() != 0 && ticks >= newDelay) {
                    ticks = 0
                    return true
                }
            }
            return false
        }

    private fun isEzTarget(target: EntityPlayer?): Boolean {
        if (FPEnabled && target != null) {
            if (target.health + target.absorptionAmount < FPHP) return true
            if (CrystalUtil.getArmourFucker(target, FPHP)) return true
            if (target.totalArmorValue < 10) return true
        }
        return false
    }

    private fun placeCs() {
        var crystalsPlaced: Short = 0
        if (target != null) {
            val possibles: List<BlockPos>? = getBestBlocks(multiplace + 1)
            if (possibles == null || possibles.isEmpty()) return
            for (i in possibles.indices) {
                val pos = possibles[i]
                if (crystalsPlaced < multiplace && Companion.mc.player.getHeldItem(
                        hand
                    ).item == Items.END_CRYSTAL && CrystalUtil.canPlaceCrystal(pos, true, false)
                ) {
                    //RenderUtil.drawSolidBlockESP(pos.getX(), pos.getY(), pos.getZ(), 1, 0.5f, 0.7f, 1);
                    if (rotate) CrystalUtil.rotateHead(
                        pos.x.toDouble(),
                        pos.y.toDouble(),
                        pos.z.toDouble(),
                        Companion.mc.player
                    )
                    BlockUtil.placeCrystalOnBlock(pos, hand, true)
                    //ChatUtil.sendMessage("Tried to place");
                    crystalsPlaced++
                    crystalsPlacedAtAll++
                }
            }
        }
    }

    @Throws(Exception::class)
    private fun breakCs() {
        val crystals = getBestCrystals(multiplace) ?: return
        //for (EntityEnderCrystal crystal : crystals) {
        for (i in crystals.indices) {
            val crystal = crystals[i]
            Companion.mc.playerController.updateController()
            if (rotate) EntityUtil.lookAtEntity(crystal)
            Companion.mc.playerController.attackEntity(Companion.mc.player, crystal)
            Companion.mc.player.swingArm(hand)
            //ChatUtil.sendMessage("Tried to break");
            crystals.clear()
            return
        }
    }

    private fun getCrystals(): ArrayList<EntityEnderCrystal> {
        val crystals = ArrayList<EntityEnderCrystal>()
        if (!Companion.mc.world.loadedEntityList.isEmpty()) {
            //for (Entity e : mc.world.loadedEntityList) {
            for (i in Companion.mc.world.loadedEntityList.indices) {
                val e = Companion.mc.world.loadedEntityList[i]
                if (e is EntityEnderCrystal && (e.getDistance(Companion.mc.player) <= attackRange) && !e.isDead) crystals.add(
                    e as EntityEnderCrystal
                )
            }
        }
        return crystals
    }

    private fun isGoodCrystal(targetCrystal: EntityEnderCrystal): Boolean {
        if (isEzTarget(target)) return CrystalUtil.calculateDamage(
            targetCrystal.position,
            target,
            shouldIgnore
        ) >= FPMinDmg && Companion.mc.player.getCooledAttackStrength(0f) == 1f
        return if (ignoreSelfD) CrystalUtil.calculateDamage(
            targetCrystal.position,
            target,
            shouldIgnore
        ) >= minDmg && Companion.mc.player.getCooledAttackStrength(0f) == 1f else target != null && CrystalUtil.calculateDamage(
            targetCrystal.position,
            target, this.shouldIgnore
        ) >= this.minDmg && CrystalUtil.calculateDamage(
            targetCrystal.position,
            Companion.mc.player,
            this.shouldIgnore
        ) <= this.maxSelfD && CrystalUtil.calculateDamage(
            targetCrystal.position,
            this.target,
            this.shouldIgnore
        ) >= CrystalUtil.calculateDamage(
            targetCrystal.position,
            Companion.mc.player,
            this.shouldIgnore
        ) && CrystalUtil.calculateDamage(
            targetCrystal.position,
            Companion.mc.player,
            false
        ) <= Companion.mc.player.health + Companion.mc.player.absorptionAmount && Minecraft.getMinecraft().player.getCooledAttackStrength(
            0f
        ) == 1f
    }

    private fun GoodnessOfCrystal(crystal: EntityEnderCrystal, target: EntityPlayer): Double {
        if (Companion.mc.player.canEntityBeSeen(crystal)) {
            if (Companion.mc.player.getDistanceSq(crystal) > MathsUtil.square(
                    attackRange.toFloat()
                )
            ) {
                return 0.0
            }
        } else {
            if (Companion.mc.player.getDistanceSq(crystal) > MathsUtil.square(
                    wallRange.toFloat()
                )
            ) {
                return 0.0
            }
        }
        if (crystal.isDead) return 0.0
        val targetDamage = CrystalUtil.calculateDamage(crystal, target, shouldIgnore).toDouble()
        if (isEzTarget(this.target) && targetDamage >= FPMinDmg) return targetDamage
        if (targetDamage < minDmg && EntityUtil.getHealth(target) - targetDamage > 0) return 0.0
        var selfDamage = 0.0
        if (!ignoreSelfD && !isEzTarget(this.target)) {
            selfDamage = CrystalUtil.calculateDamage(
                crystal, Companion.mc.player,
                shouldIgnore
            ).toDouble()
            if (targetDamage < this.minDmg || selfDamage > maxSelfD || targetDamage < selfDamage) return 0.0
        }
        if (selfDamage > maxSelfD) return 0.0
        if (EntityUtil.getHealth(Companion.mc.player) - selfDamage <= 0 && avoidSuicide) return 0.0
        when (logic) {
            "Safe" -> return targetDamage - selfDamage
            "Damage" -> return targetDamage
        }
        return 0.0
    }

    private fun GoodnessOfBlock(blockPos: BlockPos, target: EntityPlayer): Double {
        if (!CrystalUtil.canSeePos(blockPos)) {
            if (Companion.mc.player.getDistanceSq(blockPos) > MathsUtil.square(
                    wallRange.toFloat()
                )
            ) {
                return 0.0
            }
        } else {
            if (Companion.mc.player.getDistanceSq(blockPos) > MathsUtil.square(
                    attackRange.toFloat()
                )
            ) {
                return 0.0
            }
        }
        val targetDamage = CrystalUtil.calculateDamage(blockPos, target, shouldIgnore).toDouble()
        if (isEzTarget(this.target) && targetDamage >= FPMinDmg) return targetDamage
        val miniumDamage = minDmg
        if (targetDamage < miniumDamage && EntityUtil.getHealth(target) - targetDamage > 0) return 0.0
        var selfDamage = 0.0
        if (!ignoreSelfD && !isEzTarget(this.target)) {
            selfDamage = CrystalUtil.calculateDamage(blockPos, mc.player, shouldIgnore).toDouble()
            if (targetDamage < this.minDmg || selfDamage > maxSelfD || targetDamage < selfDamage) return 0.0
        }
        if (selfDamage > maxSelfD) return 0.0
        if (EntityUtil.getHealth(Companion.mc.player) - selfDamage <= 0 && avoidSuicide) return 0.0
        when (logic) {
            "Safe" -> return targetDamage - selfDamage
            "Damage" -> return targetDamage
        }
        return 0.0
    }

    private fun getBestBlocks(quantity: Int): ArrayList<BlockPos>? {
        val pos2return = ArrayList<BlockPos>()
        val allPoses = ArrayList(CrystalUtil.possiblePlacePositions(attackRange.toFloat(), true, false))
        if (!allPoses.isEmpty() && target != null && allPoses.size >= quantity) {
            for (i in 0 until quantity) {
                var bestIndex = 0
                var bestCoefficient = 0.0
                for (j in allPoses.indices) {
                    val currentCoefficient = GoodnessOfBlock(allPoses[j], target!!)
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient
                        bestIndex = j
                    }
                }
                pos2return.add(allPoses[bestIndex])
                allPoses.removeAt(bestIndex)
                bestIndex = 0
            }
            return pos2return
        }
        return null
    }

    private fun getBestCrystals(quantity: Int): ArrayList<EntityEnderCrystal?>? {
        val crystals2return: ArrayList<EntityEnderCrystal?> = ArrayList()
        val allCrystals = ArrayList(crystals)
        if (!allCrystals.isEmpty() && target != null && allCrystals.size >= quantity) {
            for (i in 0 until quantity) {
                var bestIndex = 0
                var bestCoefficient = 0.0
                for (l in allCrystals.indices) {
                    val currentCoefficient = GoodnessOfCrystal(allCrystals[l], target!!)
                    if (currentCoefficient > bestCoefficient) {
                        bestCoefficient = currentCoefficient
                        bestIndex = l
                    }
                }
                try {
                    crystals2return.add(allCrystals[bestIndex])
                    allCrystals.removeAt(bestIndex)
                } catch (ex: Exception) {
                    ChatUtil.sendMessage("Shit! Array problem")
                }
                bestIndex = 0
            }
            return crystals2return
        }
        return null
    }

    @Throws(Exception::class)
    private fun getTarget(): EntityPlayer? {
        val targets: ArrayList<EntityPlayer?> = ArrayList()
        if (armorCheck) {
            for (player in Companion.mc.world.playerEntities) {
                if (player.totalArmorValue > 0 && !player.isDead && !FriendsManager.isFriend(player.name) && player.getDistance(
                        Companion.mc.player
                    ) <= range && player !== Companion.mc.player
                ) targets.add(player)
            }
        } else {
            for (player in Companion.mc.world.playerEntities) {
                if (!player.isDead && !FriendsManager.isFriend(player.name) && player.getDistance(Companion.mc.player) <= range && player !== Companion.mc.player) targets.add(
                    player
                )
            }
        }
        var closestPlayer: EntityPlayer? = null
        for (i in targets.indices) {
            if (i == 0) closestPlayer = targets[0] else {
                if (targets[i]!!.getDistance(Companion.mc.player) < closestPlayer!!.getDistance(Companion.mc.player)) closestPlayer =
                    targets[i]
            }
        }
        return closestPlayer
    }

    private fun findCrystalsHotbar(): Int {
        for (i in 0..8) {
            if (Companion.mc.player.inventory.getStackInSlot(i).item === Items.END_CRYSTAL) {
                return i
            }
        }
        return -1
    }

    companion object {
        //CA mechanism vars
        @JvmStatic
        var pubTarget: EntityPlayer? = null;
        var mc = Minecraft.getMinecraft()
        var publicTarget: EntityPlayer? = null
    }
}