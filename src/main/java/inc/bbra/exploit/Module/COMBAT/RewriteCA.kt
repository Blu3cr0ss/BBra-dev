package inc.bbra.exploit.Module.COMBAT

import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.*
import inc.bbra.exploit.mc
import inc.bbra.exploit.utils.ChatUtil
import inc.bbra.exploit.utils.DamageUtil
import inc.bbra.exploit.utils.other.Globals
import kotlinx.coroutines.*
import net.minecraft.enchantment.EnchantmentHelper
import net.minecraft.entity.Entity
import net.minecraft.entity.EntityLivingBase
import net.minecraft.entity.SharedMonsterAttributes
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Blocks
import net.minecraft.init.MobEffects
import net.minecraft.network.play.client.CPacketAnimation
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock
import net.minecraft.util.CombatRules
import net.minecraft.util.DamageSource
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.AxisAlignedBB
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.MathHelper
import net.minecraft.util.math.Vec3d
import net.minecraft.world.Explosion
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard
import kotlin.math.abs


class RewriteCA : Module("CA Rewrite", Keyboard.KEY_NONE, Category.COMBAT) {

    ////////////////////////////// DELAYS
    val pageDelays = PageSetting(this, "Delays")
    val placeDelay = IntSetting(this, "Place Delay", pageDelays, 0, 0, 10)
    val breakDelay = IntSetting(this, "Break Delay", pageDelays, 0, 0, 10)

    ////////////////////////////// RANGES
    val pageRanges = PageSetting(this, "Ranges")
    val placeRange = IntSetting(this, "Place Range", pageRanges, 5, 1, 7)
    val breakRange = IntSetting(this, "Break Range", pageRanges, 5, 1, 7)
    val targetRange = IntSetting(this, "Target Range", pageRanges, 12, 2, 32)
    val throughBlocks = BoolSetting(this, "Through Blocks", pageRanges, true)

    ///////////////////////////// DAMAGES
    val pageDamages = PageSetting(this, "Damages")
    val antiSuicide = BoolSetting(this, "Anti Suicide", pageDamages, true)
    val selfDamage = FloatSetting(this, "Self Damage", pageDamages, 8f, 1f, 16f)
    val placeDamage = FloatSetting(this, "Place Damage", pageDamages, 4f, 1f, 36f)
    val instaBreak = BoolSetting(this, "Insta Break", pageDamages, true)
    val breakDamage = FloatSetting(this, "Break Damage", pageDamages, 4f, 1f, 36f)

    ///////////////////////////// HAND
    val pageHands = PageSetting(this, "Hands")
    val placeHand = ModeSetting(this, "Place Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val breakHand = ModeSetting(this, "Break Hand", pageHands, arrayListOf("MAINHAND", "OFFHAND"))
    val swing = BoolSetting(this, "Swing", pageHands, false)

    ///////////////////////////// HELPING
    val multiplace = IntSetting(this, "MultiPlace", 1, 1, 3)
    val helpingBlocks = BoolSetting(this, "Helping Blocks", true)
    val facePlace = BoolSetting(this, "FacePlace", false)
    val targeting = ModeSetting(this, "Targeting", arrayListOf("Health", "Range"))


    var target: EntityPlayer? = null
    var myCrystals = emptyArray<EntityEnderCrystal>()
    var placedCrystalsForMeter = 0
    var ticksPassed = 0

    var getTargetCoroutine: Job? = null
    override fun onEnable() {
        super.onEnable()
        getTargetCoroutine = GlobalScope.launch {
            while (true) {
                getTarget()
                delay(1000)
            }
        }
    }

    override fun onDisable() {
        ChatUtil.sendMessage("CA speed: "+placedCrystalsForMeter/(ticksPassed/20))
        getTargetCoroutine?.cancel()
        placedCrystalsForMeter = 0
        ticksPassed = 0
        super.onDisable()
    }

    @SubscribeEvent
    fun onTick(e: PlayerTickEvent) {
        try {
            doDelaying()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun doDelaying() {
        if (placeDelay.`val` == 0) {
            taskPlace()
        } else {
            if (ticksPlace == 0) {
                taskPlace()
            }
            doDelayPlace()
        }
        if (instaBreak.`val`) {
            taskBreak()
        } else {
            if (ticksBreak == 0) {
                taskBreak()
            }
            doDelayBreak()
        }
    }

    var ticksPlace = 0
    fun doDelayPlace() {
        if (ticksPlace != placeDelay.`val`) {
            ticksPlace += 1
        } else ticksPlace = 0
    }

    var ticksBreak = 0
    fun doDelayBreak() {
        if (ticksPlace != breakDelay.`val`) {
            ticksBreak += 1
        } else ticksBreak = 0
    }

    fun taskPlace() {
        if (target != null) {
            getPossibleCrystals()
            if (!facePlace.`val`) {
                possibleCrystals.forEach {
                    placeCrystalOnBlock(
                        it,
                        if (placeHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND,
                        swing.`val`
                    )
                    placedCrystalsForMeter+=1
                }
            } else {

            }
            possibleCrystals.clear()
        }
    }

    var possibleCrystals = arrayListOf<BlockPos>()
    fun getPossibleCrystals() = GlobalScope.launch {
        var blocksAround = arrayListOf<BlockPos>()
        var blocksDamage = hashMapOf<BlockPos, Float>()

        for (i in -placeRange.`val` until placeRange.`val`) {
            for (j in -placeRange.`val` until placeRange.`val`) {
                blocksAround.add(BlockPos(target!!.posX + i, target!!.posY, target!!.posX + j))
            }
        }

        blocksAround.forEach {
            calculateDamage(it, target)?.let { it1 -> blocksDamage.put(it, it1) }
        }

        for (i in 1 until multiplace.`val`) {
            val add = blocksDamage.maxBy {
                it.value
            }?.key

            if (add != null) {
                possibleCrystals.add(add)
                blocksDamage.remove(add)
            }
        }

        this.cancel()
    }

    fun getTarget() {
        val possibleTargets = mc.world.playerEntities.filter { it.getDistance(mc.player) <= targetRange.`val` }
        if (targeting.`val` == "Range") {
            target = possibleTargets.minBy {
                it.getDistance(mc.player)                                        // Min distance
            }
        } else {
            target = possibleTargets.minBy {
                it.health                                                       // Min health
            }
        }
    }

    fun taskBreak() {
        if (!antiSuicide.`val`) {
            myCrystals.forEach {
                if (!it.isInvulnerable && !it.isDead && it.getDistance(mc.player) <= breakRange.`val` // Checks if its goes gm1, dead, in range
                ) {
                    breakCrystal(
                        it,
                        if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND,
                        swing.`val`
                    ) // Pretty simple yeah?
                }
            }
        } else {
            myCrystals.forEach {
                val dmg = calculateDamage(it.position, mc.player)
                if (dmg != null) {
                    if (dmg <= selfDamage.`val` && dmg < mc.player.health) {
                        if (!it.isInvulnerable && !it.isDead && it.getDistance(mc.player) <= breakRange.`val` // Checks if its goes gm1, dead, in range
                        ) {
                            breakCrystal(
                                it,
                                if (breakHand.`val` == "MAINHAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND,
                                swing.`val`
                            ) // Pretty simple yeah?
                        }
                    }
                }
            }
        }
    }
}

///////////////////////////////////////// UTIL

fun canPlaceLightweight(blockPos: BlockPos): Boolean {
    if (Globals.mc.world.getBlockState(blockPos).block !== Blocks.BEDROCK && Globals.mc.world.getBlockState(blockPos).block !== Blocks.OBSIDIAN) {
        return false
    }
    if (Globals.mc.world.getBlockState(blockPos.add(0, 1, 0)).block !== Blocks.AIR || Globals.mc.world.getBlockState(
            blockPos.add(
                0,
                2,
                0
            )
        ).block !== Blocks.AIR
    ) {
        return false
    }
    return Globals.mc.world.getEntitiesWithinAABB(Entity::class.java, AxisAlignedBB(blockPos.add(0, 1, 0)))
        .isEmpty() && Globals.mc.world.getEntitiesWithinAABB(
        Entity::class.java, AxisAlignedBB(blockPos.add(0, 2, 0))
    ).isEmpty()
}

fun placeCrystalOnBlock(pos: BlockPos, hand: EnumHand?, swing: Boolean) {
    val result = Globals.mc.world.rayTraceBlocks(
        Vec3d(
            Globals.mc.player.posX,
            Globals.mc.player.posY + Globals.mc.player.getEyeHeight().toDouble(),
            Globals.mc.player.posZ
        ), Vec3d(pos.x.toDouble() + 0.5, pos.y.toDouble() - 0.5, pos.z.toDouble() + 0.5)
    )
    val facing = if (result?.sideHit == null) EnumFacing.UP else result.sideHit
    Globals.mc.player.connection.sendPacket(CPacketPlayerTryUseItemOnBlock(pos, facing, hand, 0.0f, 0.0f, 0.0f))
    if (swing) {
        Globals.mc.player.connection.sendPacket(CPacketAnimation(hand))
    }
}

fun breakCrystal(target: Entity?, hand: EnumHand?, swing: Boolean) {
    mc.playerController.attackEntity(mc.player, target)
    if (swing) {
        mc.player.swingArm(hand)
    }
    mc.player.resetCooldown()
}

fun calculateDamage(pos: BlockPos, entity: Entity?): Float? {
    return entity?.let { calculateDamage(pos.x.toDouble() + 0.5, (pos.y + 1).toDouble(), pos.z.toDouble() + 0.5, it) }
}

fun calculateDamage(posX: Double, posY: Double, posZ: Double, entity: Entity): Float {
    val doubleExplosionSize = 12.0f
    val distancedsize = entity.getDistance(posX, posY, posZ) / doubleExplosionSize.toDouble()
    val vec3d = Vec3d(posX, posY, posZ)
    var blockDensity = 0.0
    try {
        blockDensity = entity.world.getBlockDensity(vec3d, entity.entityBoundingBox).toDouble()
    } catch (exception: java.lang.Exception) {
        // empty catch block
    }
    val v = (1.0 - distancedsize) * blockDensity
    val damage = ((v * v + v) / 2.0 * 7.0 * doubleExplosionSize.toDouble() + 1.0).toInt().toFloat()
    var finald = 1.0f
    if (entity is EntityLivingBase) {
        finald = getBlastReduction(
            entity,
            getDamageMultiplied(damage),
            Explosion(DamageUtil.mc.world, null, posX, posY, posZ, 6.0f, false, true)
        )
    }
    return finald
}


fun getBlastReduction(entity: EntityLivingBase, damageI: Float, explosion: Explosion?): Float {
    var damage = damageI
    if (entity is EntityPlayer) {
        val ep = entity
        val ds = DamageSource.causeExplosionDamage(explosion)
        damage = CombatRules.getDamageAfterAbsorb(
            damage,
            ep.totalArmorValue.toFloat(),
            ep.getEntityAttribute(SharedMonsterAttributes.ARMOR_TOUGHNESS).attributeValue.toFloat()
        )
        var k = 0
        try {
            k = EnchantmentHelper.getEnchantmentModifierDamage(ep.armorInventoryList, ds)
        } catch (exception: java.lang.Exception) {
            // empty catch block
        }
        val f = MathHelper.clamp(k.toFloat(), 0.0f, 20.0f)
        damage *= 1.0f - f / 25.0f
        if (entity.isPotionActive(MobEffects.RESISTANCE)) {
            damage -= damage / 4.0f
        }
        damage = Math.max(damage, 0.0f)
        return damage
    }
    damage = CombatRules.getDamageAfterAbsorb(
        damage,
        entity.totalArmorValue.toFloat(),
        entity.getEntityAttribute(SharedMonsterAttributes.ARMOR_TOUGHNESS).attributeValue.toFloat()
    )
    return damage
}

fun getDamageMultiplied(damage: Float): Float {
    val diff: Int = DamageUtil.mc.world.difficulty.difficultyId
    return damage * if (diff == 0) 0.0f else if (diff == 2) 1.0f else if (diff == 1) 0.5f else 1.5f
}