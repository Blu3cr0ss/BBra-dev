package inc.bbra.exploit.Module.MISC

import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.BoolSetting
import inc.bbra.exploit.clickgui.modules.settings.IntSetting
import inc.bbra.exploit.utils.ChatUtil
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientDisconnectionFromServerEvent
import org.lwjgl.input.Keyboard
import java.io.File
import java.io.IOException
import java.util.*
import kotlin.random.Random

class Spammer : Module("Spammer", Keyboard.KEY_NONE, Category.MISC) {
    var ticksS = IntSetting(this, "Ticks", 100, 50, 250)
    var end = BoolSetting(this, "Ending", true)
    var offOnLeave = BoolSetting(this, "Off on leave", true)
    var randomize = BoolSetting(this, "Randomize msgs", false)

    ////////// stuff vars
    private var ending = true
    private var doStop = true
    private var spamLines = ArrayList<String>()
    private var spamLineNumber = 0
    private var prevRandom: Int? = null

    @Throws(IOException::class)
    override fun onEnable() {
        loadLines()
        super.onEnable()
    }

    override fun onDisable() {
        endingNum = 0
        super.onDisable()
    }

    @SubscribeEvent
    fun onPlayerTickEvent(e: PlayerTickEvent?) {
        ending = end.getVal()
        doStop = offOnLeave.getVal()
        if (!spamLines.isEmpty()) {
            if (ticks % ticksS.getVal() * 20 == 0 && ending) {
                mc.player.sendChatMessage(spamLines[spamLineNumber] + " | " + endingNum)
                endingNum++
                if (randomize.`val`){
                    getRandomSpamLineNumber()
                }else{
                    switchSpamText()
                }
            } else if (ticks % ticksS.getVal() * 20 == 0) {
                mc.player.sendChatMessage(spamLines[spamLineNumber])
                if (randomize.`val`){
                    getRandomSpamLineNumber()
                }else{
                    switchSpamText()
                }
            }
            ticks++
        }
    }

    private fun switchSpamText() {
        if (spamLineNumber == spamLines.size - 1) {
            spamLineNumber = 0
        } else spamLineNumber++
    }

    private fun getRandomSpamLineNumber() {
        var random = Random.nextInt(0, spamLines.size)
        while (random == prevRandom){
            random = Random.nextInt(0, spamLines.size)
        }
        prevRandom = random
        spamLineNumber = random
    }

    @SubscribeEvent
    @Throws(IOException::class)
    fun onLeave(event: ClientDisconnectionFromServerEvent?) {
        if (doStop) {
            setToggled(false)
        }
    }

    @Throws(IOException::class)
    fun loadLines() {
        try {
            spamLines.clear()
            val reader = File("BBraExploit/spammer.txt")
            if (!reader.exists()) {
                reader.createNewFile()
            }
            spamLines = reader.readText().split("\n") as ArrayList<String>
        } catch (e: Exception) {
            ChatUtil.sendMessage("Spammer error")
        }
    }

    companion object {
        private val text: String? = null
        private var endingNum = 0
        private var ticks = 0
        private const val line = 0
    }
}