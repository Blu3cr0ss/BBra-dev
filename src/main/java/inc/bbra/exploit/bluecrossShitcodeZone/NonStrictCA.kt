package inc.bbra.exploit.bluecrossShitcodeZone

import inc.bbra.exploit.BBraExploit
import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.IntSetting
import inc.bbra.exploit.clickgui.modules.settings.ModeSetting
import inc.bbra.exploit.event.events.MoveEvent
import inc.bbra.exploit.event.events.PacketSentEvent
import inc.bbra.exploit.utils.CrystalUtil
import inc.bbra.exploit.utils.EntityUtil
import inc.bbra.exploit.utils.InventoryUtil
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.item.ItemEndCrystal
import net.minecraft.network.play.client.CPacketHeldItemChange
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent
import org.lwjgl.input.Keyboard

object NonStrictCA : Module("Non strict", Keyboard.KEY_NONE, Category.COMBAT) {

    private val targeting = ModeSetting(this, "Targeting", arrayListOf("Health", "Range"))
    private val targetDistance = IntSetting(this, "Target Dist", 12, 4, 24)
    private val range = IntSetting(this, "Range", 6, 2, 9)
    private val autoSwitch = ModeSetting(this, "Auto Switch", arrayListOf("None", "Normal", "Silent"))
    private val selfDmg = IntSetting(this, "Self Dmg", 8, 1, 16)
    private val minDmg = IntSetting(this, "Min Dmg", 3, 1, 16)

    var target: EntityPlayer? = null

    @SubscribeEvent
    fun everyTick(e: PlayerTickEvent) {
        if (mc.player != null
        ) {
            target = getTarget()
            switch()
            placeCrystal()
        }
    }

    @SubscribeEvent
    fun breakCrystal(e: PacketSentEvent) {
        var packet = e.packet
        if (packet is CPacketPlayerTryUseItemOnBlock && isHoldingCrystal()) {
            val crystal = getValidCrystals().firstOrNull {
                it.position == packet.pos
            }
            BBraExploit.logger.info(crystal)
            if (crystal != null) {
//                mc.connection?.sendPacket(CPacketUseEntity(crystal, EnumHand.MAIN_HAND))
                EntityUtil.attackEntity(crystal, true, false, EnumHand.MAIN_HAND)
                crystal.setDead()
                BBraExploit.logger.info("Breaked at ${crystal.position}")
            }
        }
    }

    var posNum = 0
    fun placeCrystal() {
        if (placePositions.size == 2) {
            val placePos = placePositions[posNum]
            posNum = if (posNum == 0) 1 else 0
            CrystalUtil.placeCrystal(placePos, EnumHand.OFF_HAND, false, false)
            BBraExploit.logger.info("Placed at $placePos")
        }
    }

    var placePositions = arrayListOf<BlockPos>()

    @SubscribeEvent
    fun recalcPlacePositions(e: MoveEvent.FullBlock) {
        if ((target != null && (e.player == mc.player || e.player == target)) || placePositions.isEmpty()) {
            calc()
        }
    }

    private fun calc() {
        if (target != null) {
            placePositions.clear()
            var possibles = arrayListOf<BlockPos>()
            possibles.addAll(CrystalUtil.possiblePlacePositions(range.`val`.toFloat(), true, false))
            possibles.removeAll {
                CrystalUtil.calculateDamage(it, target, false) < minDmg.`val` || CrystalUtil.calculateDamage(
                    it,
                    mc.player,
                    false
                ) > selfDmg.`val`
            }
            if (!possibles.isNullOrEmpty()) {
                val adding = possibles.maxBy {
                    CrystalUtil.calculateDamage(it, target, false) - CrystalUtil.calculateDamage(
                        it,
                        mc.player,
                        false
                    )
                }!!
                if (adding != null) {
                    placePositions.add(
                        adding
                    )
                    possibles.removeAll {
                        it.x == adding.x || it.x == adding.x + 1 || it.x == adding.x - 1 || it.z == adding.z || it.z == adding.z + 1 || it.z == adding.z - 1
                    }
                }
            }
            if (!possibles.isNullOrEmpty()) {
                val secondCrystal = possibles.maxBy {
                    CrystalUtil.calculateDamage(it, target, false)
                }!!
                if (secondCrystal != null) {
                    placePositions.add(
                        secondCrystal
                    )
                }
                possibles.remove(secondCrystal)
            }
            BBraExploit.logger.info(placePositions)
        }
    }

    var silentlySwitched = false
    private fun isHoldingCrystal(): Boolean {
        val isHolding = if (!silentlySwitched) mc.player.inventory.offHandInventory.map { it.item }      // 40
            .first() is ItemEndCrystal else true
        BBraExploit.logger.info("is holding crystal: $isHolding")
        BBraExploit.logger.info("silent switch: $silentlySwitched")
        return isHolding
    }

    private fun switch() {
        val slot = InventoryUtil.findItemInHotbar(Items.END_CRYSTAL)
        if (slot != mc.player.inventory.currentItem && !isHoldingCrystal()) {
            when (autoSwitch.`val`) {
                "NONE" -> {
                    silentlySwitched = false
                    return
                }

                "NORMAL" -> {
                    mc.player.inventory.currentItem = slot
                    mc.player.connection.sendPacket(CPacketHeldItemChange(slot))
                    mc.playerController.updateController()
                    silentlySwitched = false
                    return
                }

                "SILENT" -> {
                    mc.player.connection.sendPacket(CPacketHeldItemChange(slot))
                    mc.playerController.updateController()
                    silentlySwitched = true
                    return
                }
            }
        }
    }

    @JvmName("getTarget1")
    private fun getTarget(): EntityPlayer? {
        return mc.world.playerEntities?.filter {
            it != mc.player &&
                    it.getDistance(mc.player) <= targetDistance.`val`
        }?.minBy {
            if (targeting.`val` == "Health") {
                it.health
            } else {
                it.getDistance(mc.player)
            }
        }
    }

    private fun getValidCrystals(): List<EntityEnderCrystal> {
        val crystals = mc.world.getLoadedEntityList().filter {
            it is EntityEnderCrystal &&
                    it.getDistance(mc.player) <= range.`val` &&
                    !it.isDead
        } as List<EntityEnderCrystal>
        return crystals.ifEmpty { emptyList() }
    }
}