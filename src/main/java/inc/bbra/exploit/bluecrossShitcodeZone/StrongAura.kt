package inc.bbra.exploit.bluecrossShitcodeZone

import idk.bbra.other.event.events.BlockBreakingEvent
import idk.bbra.other.event.events.DeathEvent
import inc.bbra.exploit.BBraExploit
import inc.bbra.exploit.Module.Module
import inc.bbra.exploit.clickgui.modules.settings.BoolSetting
import inc.bbra.exploit.clickgui.modules.settings.IntSetting
import inc.bbra.exploit.clickgui.modules.settings.ModeSetting
import inc.bbra.exploit.event.events.PacketGetEvent
import inc.bbra.exploit.event.events.PacketSentEvent
import inc.bbra.exploit.utils.ChatUtil
import inc.bbra.exploit.utils.CrystalUtil
import inc.bbra.exploit.utils.EntityUtil
import inc.bbra.exploit.utils.InventoryUtil
import kotlinx.coroutines.*
import net.minecraft.entity.item.EntityEnderCrystal
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.init.Items
import net.minecraft.network.play.client.CPacketHeldItemChange
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock
import net.minecraft.network.play.client.CPacketUseEntity
import net.minecraft.network.play.server.SPacketExplosion
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent.ServerTickEvent
import org.lwjgl.input.Keyboard


object StrongAura : Module("StrongAura", Keyboard.KEY_NONE, Category.COMBAT) {

    private val targeting = ModeSetting(this, "Targeting", arrayListOf("Health", "Range"))
    private val targetDistance = IntSetting(this, "Target Dist", 12, 4, 24)
    private val range = IntSetting(this, "Range", 6, 2, 9)
    private val autoSwitch = ModeSetting(this, "Auto Switch", arrayListOf("None", "Normal", "Silent"))
    private val placeHand = ModeSetting(this, "Place Hand", arrayListOf("MAIN_HAND", "OFF_HAND"))
    private val breakHand = ModeSetting(this, "Break Hand", arrayListOf("MAIN_HAND", "ON_HAND"))
    private val multiplace = IntSetting(this, "Multiplace", 1, 1, 5)
    private val placementMode = ModeSetting(this, "Placement Mode", arrayListOf("Benefit", "Damage"))
    private val faceplace = BoolSetting(this, "Faceplace", false)
    private val selfDmg = IntSetting(this, "Self Dmg", 8, 1, 16)
    private val minDmg = IntSetting(this, "Min Dmg", 3, 1, 16)
    private val placeSwing = BoolSetting(this, "Swing Place", false)
    private val breakSwing = BoolSetting(this, "Break Swing", false)
    private val rotate = BoolSetting(this, "Rotate", false)

    private var target: EntityPlayer? = null

    override fun onEnable() {
        ChatUtil.sendMessage("123")
        super.onEnable()
    }

    override fun onDisable() {
        super.onDisable()
    }

    @SubscribeEvent
    fun onTick(e: ServerTickEvent) {
        getTarget()
        if (target != null) {
            BBraExploit.logger.info("target is " + target?.name)
            checkSlot()
            BBraExploit.logger.info(haveCrystal)
            if (haveCrystal) {
                catchMove()
                if (shouldRecalcPlacePos) {
                    doPlacementCalc()
                    ChatUtil.sendMessage("recalcPlacePos")
                }

                if (haveCrystal) {
                    doSwitch(crystalAt.first())
                    doPlace()
                    BBraExploit.logger.info("do place")
                }

                doBreak()
                BBraExploit.logger.info("do break")
            }
        }

    }

    var shouldRecalcPlacePos = true
    var prevTargetPos = target?.position
    var prevPlayerPos = mc.player?.position
    private fun catchMove() {
        val newTargetPos = target?.position
        val newPlayerPos = mc.player?.position
        if (newTargetPos != null && newPlayerPos != null) {
            shouldRecalcPlacePos = prevPlayerPos != newPlayerPos || prevTargetPos != newTargetPos
            prevTargetPos = newTargetPos
            prevPlayerPos = newPlayerPos
            return
        }
    }

    var haveCrystal = false
    var crystalAt = arrayListOf(-1)
    private fun checkSlot() {
        if (placeHand.`val` == "OFF_HAND" && mc.player.inventory.getStackInSlot(45).item === Items.END_CRYSTAL) {
            haveCrystal = true
            crystalAt.clear()
            crystalAt.add(45)
            return
        } else if (placeHand.`val` == "MAIN_HAND") {
            crystalAt.clear()
            repeat(9) {
                if (mc.player.inventory.getStackInSlot(it).item === Items.END_CRYSTAL) {
                    haveCrystal = true
                    crystalAt.add(it)
                }
            }
            return
        }
        haveCrystal = false
        crystalAt.clear()
    }

    private fun getTarget() {
        target = mc.world.playerEntities.filter {
            it.entityId != mc.player.entityId &&
                    it.getDistance(mc.player) <= targetDistance.`val`
        }.minBy {
            if (targeting.`val` == "Health") {
                it.health
            } else {
                it.getDistance(mc.player)
            }
        }
    }


    private fun doSwitch(slot: Int) {
        if (slot != 0 && slot != mc.player.inventory.currentItem) {
            when (autoSwitch.`val`) {
                "NONE" -> return
                "SILENT" -> {
                    mc.player.connection.sendPacket(CPacketHeldItemChange(slot))
                    mc.playerController.updateController()
                    ChatUtil.sendMessage("SILENTLY SWITCHED")
                    return
                }
                "NORMAL" -> {
                    mc.player.inventory.currentItem = slot
                    mc.player.connection.sendPacket(CPacketHeldItemChange(slot))
                    mc.playerController.updateController()
                    ChatUtil.sendMessage("NORMALY SWITCHED")
                    return
                }
            }
        }
    }

    var placePositions = arrayListOf<BlockPos>()
    fun doPlacementCalc() {
        placePositions.clear()
        var possibles = CrystalUtil.possiblePlacePositions(range.`val`.toFloat(), true, false)
        var pos2return = arrayListOf<BlockPos>()

        val selfDmg = selfDmg.`val`
        val minDmg = minDmg.`val`
        val faceplace = faceplace.`val`
        val multiplace = multiplace.`val`
        val placementMode = placementMode.`val`

        possibles.removeIf {
            CrystalUtil.calculateDamage(it, mc.player, false) > selfDmg
            CrystalUtil.calculateDamage(it, target, faceplace) < minDmg
        }
        if (possibles.size >= multiplace) {
            when (placementMode) {
                "Benefit" -> {
                    repeat(multiplace) {
                        val what2add = possibles.maxBy {
                            CrystalUtil.calculateDamage(it, target, faceplace) - CrystalUtil.calculateDamage(
                                it,
                                mc.player,
                                false
                            )
                        }!!
                        pos2return.add(
                            what2add
                        )
                        possibles.removeAll(
                            setOf(
                                what2add,
                                BlockPos(what2add.x + 1, what2add.y, what2add.z),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z - 1),
                                BlockPos(what2add.x + 1, what2add.y, what2add.z - 1),
                                BlockPos(what2add.x + 1, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x, what2add.y, what2add.z - 1)
                            )
                        )
                    }
                }
                "Damage" -> {
                    repeat(multiplace) {
                        val what2add = possibles.maxBy {
                            CrystalUtil.calculateDamage(it, target, faceplace)
                        }!!
                        pos2return.add(
                            what2add
                        )
                        possibles.removeAll(
                            setOf(
                                what2add,
                                BlockPos(what2add.x + 1, what2add.y, what2add.z),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x - 1, what2add.y, what2add.z - 1),
                                BlockPos(what2add.x + 1, what2add.y, what2add.z - 1),
                                BlockPos(what2add.x + 1, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x, what2add.y, what2add.z + 1),
                                BlockPos(what2add.x, what2add.y, what2add.z - 1)
                            )
                        )
                    }
                }
            }
        }
        placePositions.addAll(pos2return)
        BBraExploit.logger.info(placePositions)
    }

    fun doPlace() {
        val hand = if (placeHand.`val` == "MAIN_HAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
        val rotate = rotate.`val`
        val placeSwing = placeSwing.`val`
        placePositions.forEach {
            CrystalUtil.placeCrystal(it, hand, placeSwing, rotate)
            breakCrystals.add(EntityEnderCrystal(mc.world, it.x.toDouble(), it.y.toDouble(), it.z.toDouble()))
        }

    }

    var breakCrystals = arrayListOf<EntityEnderCrystal?>()
    fun doBreak() {
        val hand = if (breakHand.`val` == "MAIN_HAND") EnumHand.MAIN_HAND else EnumHand.OFF_HAND
        breakCrystals.addAll(
            placePositions.map {
                getValidCrystals().takeIf {
                    !it.isNullOrEmpty()
                }?.firstOrNull { zxc ->
                    zxc.position.x == it.x &&
                            zxc.position.y == it.y &&
                            zxc.position.z == it.z
                }
            }
        )
        ChatUtil.sendMessage((getValidCrystals().map { it.position }).toString())
        if (!breakCrystals.contains(null)) {
            val breakSwing = breakSwing.`val`
            breakCrystals.forEach {
                EntityUtil.attackEntity(it, true, breakSwing, hand)
            }
        }
        breakCrystals.clear()
    }

    @SubscribeEvent
    fun detectUnsurounded(e: BlockBreakingEvent) {
        if (target != null) {
            val surroundPositions = listOf<BlockPos>(
                BlockPos(target!!.posX + 1, target!!.posY, target!!.posZ),
                BlockPos(target!!.posX - 1, target!!.posY, target!!.posZ),
                BlockPos(target!!.posX, target!!.posY, target!!.posZ + 1),
                BlockPos(target!!.posX, target!!.posY, target!!.posZ - 1)
            )
            if (surroundPositions.contains(e.pos)) {
                ChatUtil.sendMessage("Find break event! stage is ${e.stage}")
            }
        }
    }

    @SubscribeEvent
    fun onEzd(e: DeathEvent) {
        if (e.player.name == target?.name) {
            mc.player.sendChatMessage(target?.name + " got ezd with power of BBraExploit!")
        }
    }


    private suspend fun calcPredictedCrystalPositions() {

    }

    @SubscribeEvent
    fun onPacketSent(e: PacketSentEvent) {
        ChatUtil.sendMessage("Send packet catched")
        val explodePacket = e.give<CPacketUseEntity>()
        val placePacket = e.give<CPacketPlayerTryUseItemOnBlock>()
        if (explodePacket.action == CPacketUseEntity.Action.ATTACK && explodePacket.getEntityFromWorld(
                mc.world
            ) is EntityEnderCrystal
        ) {
            mc.world.removeEntityFromWorld(explodePacket.getEntityFromWorld(mc.world)!!.entityId)
            ChatUtil.sendMessage("breaked crystal!")
        }
        if (InventoryUtil.findItemsInHotbar(Items.END_CRYSTAL)
                .contains(mc.player.inventory.currentItem)
        ) {
            ChatUtil.sendMessage("we placed crystal!")
        }
    }

    @SubscribeEvent
    fun onPacketGet(e: PacketGetEvent) {
        ChatUtil.sendMessage("Receive packet catched")
        val explosion = e.give<SPacketExplosion>()
        if (placePositions.contains(BlockPos(explosion.x, explosion.y, explosion.z))) {
            breakCrystals.remove(EntityEnderCrystal(mc.world, explosion.x, explosion.y, explosion.z))
            ChatUtil.sendMessage("new explosion packet!")
        }
    }

    private fun getValidCrystals(): List<EntityEnderCrystal> {
        val crystals = mc.world.getLoadedEntityList().filter {
            it is EntityEnderCrystal &&
                    it.getDistance(mc.player) <= range.`val` &&
                    !it.isDead
        } as List<EntityEnderCrystal>
        return crystals.ifEmpty { emptyList() }
    }

}